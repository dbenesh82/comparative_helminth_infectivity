---
title: "Establishment probability in worms"
output: 
  html_document:
    keep_md: true
    toc: true
    df_print: kable
---

Parasitic worms often have complex life cycles, where they infect multiple hosts in succession before reproducing. Each step in the life cycle involves a risk, as some parasites will fail to infect the next host in the cycle. But is this risk consistent? Using a dataset of experimental infections from over a hundred worms, we examine what impacts how likely it is for parasites to establish infection in their next hosts.

```{r setup, include=FALSE}
library(tidyverse)
library(MCMCglmm)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
options(stringsAsFactors = FALSE)
theme_set(new = theme_bw())
```
```{r}
dat <- read.csv(file = "../../data/er_combined.csv", header = T)
tree <- read.tree(file = "../../data/full_tree_time_calib.nex")
```
```{r}
# for matching tree tips and species name in data frame
tips <- read.csv(file = "../../data/data_tree_tips_table.csv")
tips$Parasite.species[which(tips$Parasite.species == "Mesocestoides corti/variabilis/vogae")] <- "Mesocestoides corti"
tips$Parasite.species[which(tips$Parasite.species == "Dioctophyma renale")] <- "Dioctophyme renale"
tips$Parasite.species[which(tips$Parasite.species == "Macracanthorhynchus hirudinaceous")] <- "Macracanthorhynchus hirudinaceus"
tips$Parasite.species[which(tips$Parasite.species == "Mesocestoides lineatus/litteratus")] <- "Mesocestoides lineatus"
tips$Parasite.species[which(tips$Parasite.species == "Anisakis pegreffii")] <- "Anisakis pegreffi" 
tips$Parasite.species[which(tips$Parasite.species == "Obeliscoides cuniculi multistriatus")] <- "Obeliscoides cuniculi" 
tips$Parasite.species[which(tips$Parasite.species == "Rodentolepis microstoma")] <- "Hymenolepis microstoma" 
dat <- left_join(dat, tips%>%distinct(), by = c("Species" = "Parasite.species"))
```
```{r}
tree <- keep.tip(tree, tip = unique(dat$tree_tips)%>%na.omit)
```
```{r}
# dat%>%
#   select(Species, Next_Host, Host_Species, to_int_def)%>%
#   distinct()%>%
#   arrange(Species, Next_Host)
```

# Descriptive stats

Number of infections (rows):

```{r}
length(dat$Species)
```

Number of species:

```{r}
n_distinct(dat$Species)
```
Number of species in each phyla:

```{r}
dat%>%
  group_by(parasite_phylum)%>%
  summarise(n_distinct(Species))
```

Number of stages:

```{r}
n_distinct(paste(dat$Species, dat$Next_Host, dat$to_int_def))
```

Number of studies:

```{r}
n_distinct(dat$Study)
```

Total number of exposed hosts:

```{r}
sum(dat$Sample_Size)
```

Summary of doses:

```{r}
summary(dat$Dose)
```

Summary of recoveries:

```{r}
summary(dat$Recovered)
```

Doses and thus recoveries vary over a large range.

# Models

For statistical modeling, we round the number of established/not established worms to integer values. In this way, we can fit logistic regression models, instead of treating recovery rate as a continuous variable.

```{r}
dat <- mutate(dat, succeeded = round(Recovered,0))%>%
  mutate(failed = round(Dose,0) - succeeded, 
         time_dpix = Time_Dissection-1) # time of dissection minus 1 puts origin at 1 dpi - reasonable for comparison (shortly after infection)
dat <- dat%>%
  mutate(tot_given = round(Sample_Size * Dose,0), tot_inf = round(Sample_Size * Dose * Recovery_Rate, 0))%>%
  mutate(succeeded = tot_inf, failed = tot_given - tot_inf)

dat <- mutate(dat, obs = 1:length(Species))
```
```{r}
dat <- mutate(dat, log_dose = log(Dose), log_dose1 = log(Dose+1), 
              log_recover = log(Recovered), log_recover1 = log(Recovered+1),
              log_failed = log(Dose - Recovered), dose_rounded = round(Dose,0))
```
```{r}
dat <- mutate(dat, nh_fac = factor(Next_Host),
              to_int_def = fct_recode(to_int_def, Intermediate = "int", Definitive = "def"))%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))

dat <- dat%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = factor(st_id, levels = c("1 Intermediate", "1 Definitive",
                                          "2 Intermediate", "2 Definitive",
                                          "3 Intermediate", "3 Definitive")))

dat <- mutate(dat, study_rs = factor(paste0(Study,":",nh_fac)),
              log_dpi = log(Time_Dissection))
# sort(unique(dat$study_rs))

dat <- mutate(dat, log_ws = log(biovolume), log_hm = log(host_bm))%>%
  mutate(log_ws_cen = log_ws - mean(log_ws, na.rm = T),
         log_hm_cen = log_hm - mean(log_hm, na.rm = T))%>%
  mutate(log_dpi_cen = log_dpi - log(14), # center time of dissection at 2 weeks pi
         log_dose_cen = log_dose - log(100) # center dose at 100
         )
```

## Model structure

First, I compare how different model structures perform. I fit models with `MCMCglmm` as it can also be used for phylogenetic analyses.

Here are the different tested models: (1) recovery rate as continuous response, (2) recovery rate as proportion (recovered and not recovered round to integers), (3) bivariate with log recovered and log dose as response variables, (4) bivariate with recovered/not recovered as counts (bivariate poisson). Notably, an error term was included in the GLMM to account for overdispersion (additive overdispersion - equivalent to adding an obs-level random effect to `glmer`). The preliminary models include several presumably important predictors, including time after infection, parasite stage, parasite size, and target host body mass. The models include study as a random effect, but not phylogeny (yet). 

```{r}
bi <- 1000
nit <- 41000
```
```{r}
# UNIVAR
# prior for univar models
prior2 <- list(R=list(V=1, nu=0.002), 
               G=list(G1=list(V=1, nu=0.002)))
# univariate - rec rate as continuous response
mod1 <- MCMCglmm(Recovery_Rate ~ log_dpi + nh_fac*to_int_def + log_ws + log_hm, 
                 random = ~ Study,
                 prior = prior2,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(dat, !is.na(biovolume), !is.na(host_bm)),
                 verbose = F)
# univariate - rec rate as proportion - same model as GLMER with obs-level random effect
mod2 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac*to_int_def + log_ws + log_hm, 
                 random = ~ Study,
                 prior = prior2,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(dat, !is.na(biovolume), !is.na(host_bm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
# BIVAR
# bivariate - rec rate as continuous response
mod3 <- MCMCglmm(cbind(log_recover1, log_dose1) ~ trait-1 + log_dpi:trait + nh_fac*to_int_def:trait +
                   log_ws:trait + log_hm:trait,
                        random = ~ us(trait):Study,
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        nitt = nit, thin = 20, burnin = bi,
                        data = filter(dat, !is.na(biovolume), !is.na(host_bm)),
                        family = c("gaussian", "gaussian"), pr=F,
                 verbose = F)
# bivariate - rec rate as rounded proportion
# mod4 <- MCMCglmm(cbind(succeeded, dose_rounded) ~ trait-1 + log_dpi:trait + nh_fac:trait + log_ws:trait, 
#                         random = ~ us(trait):Study,
#                         rcov = ~us(trait):units, # residual var-covar unstructured
#                         nitt = nit, thin = 20,
#                         data = filter(dat, !is.na(biovolume)), 
#                         family = c("poisson", "poisson"), pr=T)
# bivariate - rec rate as rounded proportion
mod5 <- MCMCglmm(cbind(succeeded, failed) ~ trait-1 + log_dpi:trait + nh_fac:trait + 
                   log_ws:trait + log_hm:trait, 
                        random = ~ us(trait):Study,
                        rcov = ~us(trait):units, # residual var-covar unstructured
                        nitt = nit, thin = 20, burnin = bi,
                        data = filter(dat, !is.na(biovolume), !is.na(host_bm)), 
                        family = c("poisson", "poisson"), pr=F,
                 verbose = F)
```

The most complex model (bivariate poisson) had decent mixing for the random effects, so the models did not have fitting issues.

```{r}
plot(mod5$VCV)
```

For each model, I extract their predictions.

```{r}
tx <- filter(dat, !is.na(biovolume), !is.na(host_bm))
tx2 <- tx
tx2.1 <- tx
tx3 <- tx
# tx4 <- tx
tx5 <- tx

tx$preds <- predict(mod1)

preds1 <- predict.MCMCglmm(mod2, type = 'terms')
tx2$preds <- boot::inv.logit(preds1)

preds1 <- predict(mod3)
tx3 <- cbind(tx3, recover_pred = exp(preds1[1:(length(preds1)/2)])-1,
             dose_pred = exp(preds1[(length(preds1)/2+1):length(preds1)])-1)
tx3 <- mutate(tx3, preds = recover_pred/dose_pred)

# preds1 <- predict(mod4)
# tx4 <- cbind(tx4, recover_pred = (preds1[1:(length(preds1)/2)]), 
#              dose_pred = (preds1[(length(preds1)/2+1):length(preds1)])) 
# tx4 <- mutate(tx4, preds = recover_pred/dose_pred)

preds1 <- predict(mod5)
tx5 <- cbind(tx5, recover_pred = (preds1[1:(length(preds1)/2)]), 
             fail_pred = (preds1[(length(preds1)/2+1):length(preds1)])) 
tx5 <- mutate(tx5, preds = recover_pred/(recover_pred + fail_pred))

tx$model <- 'Univ, LMM'
tx2$model <- 'Univ, GLMM'
tx3$model <- 'Biv, LMM'
# tx4$model <- 'Biv, GLMM, s&d'
tx5$model <- 'Biv, GLMM, s&f'

tx <- bind_rows(tx, tx2, tx3, tx5)
rm(tx2, tx2, tx3, tx5)
```

Then I compare predictions from different models with observed values. The bivariate LMM is the worse - it has many predicted recovery rates above 1.

```{r}
ggplot(tx, aes(y = preds, x = Recovery_Rate, color = model)) +
  geom_point(aes(), alpha = 0.2) +
  geom_abline(intercept = 0, slope = 1, linetype = 'dashed', size = 1.5) +
  geom_smooth(se = F) +
  labs(x = "Observed", y = "Predicted")
```

When reduced to only plausible values, the univariate GLMM model looks best.

```{r}
ggplot(filter(tx, preds < 1),
       aes(y = preds, x = Recovery_Rate, color = model)) +
  geom_point(aes(), alpha = 0.05) +
  geom_abline(intercept = 0, slope = 1, linetype = 'dashed', size = 1.5) +
  geom_smooth(se = F) +
  labs(x = "Observed", y = "Predicted")
```
Residual plots. The bivariate LMM is the worst. The univariate GLMM looks the best.

```{r}
ggplot(filter(tx, !is.na(preds)),
       aes(y = Recovery_Rate - preds, x = preds, color = model)) +
  geom_point(aes(), alpha = 0.1) +
  geom_abline(intercept = 0, slope = 0) + 
  geom_smooth() +
  facet_wrap(~model, scales = 'free') +
  labs(x = "Fitted values", y = "Unstandardized Residuals")
```

```{r}
tx_preds <- dplyr::select(tx, rr = preds, model)
tx_obs <- filter(tx, model == "Univ, LMM")%>%
  dplyr::select(rr = Recovery_Rate, model)
tx_obs$model <- "observed"

txx <- bind_rows(tx_preds, tx_obs)
```

Another way to check model fit is to compare the distribution of predictions with that of the observations. Here are density plots for the predicted values. We can see that some models yield predictions more closely matching the data than others, but it is a little hard to tell with the substantial right-skew in the data.

```{r}
ggplot(filter(txx, rr <=1), aes(x = rr, fill = model)) +
  geom_density() +
  facet_wrap(~model, ncol = 1) 
```

Here are the distributions overlapping. The univariate GLMM performs best, i.e. it comes closest to the observed data distribution.

```{r}
ggplot(filter(txx, model == 'observed'),
       aes(x = rr)) +
  geom_density(color = 'black', size = 2) +
  geom_density(data = filter(txx, model != 'observed'), 
               aes(color = model), size = 1) +
  theme(panel.grid.minor = element_blank()) +
  coord_cartesian(xlim = c(0,1))
```

The chains for the variance components in this "best" model mixed fine.

```{r}
plot(mod2$VCV)
```

In these models, we included several presumably important predictors. We test these more formally below, but here's the model summary:

```{r}
summary(mod2)
```

The model suggests that (i) recovery goes down with time post infection, (ii) recovery is higher in second definitive hosts and lower in first definitive hosts, (iii) that large larvae have higher establishment rates, (iv) that establishment is unrelated to host mass, and (v) considerable residual variance is between studies.

## Level of analysis - host or condition?

The data were often collected at the level of individual hosts. For example, a study may have infected 5 hosts and then dissected them at 5 different time points. Or those 5 hosts may have been given different doses. We did not pool these hosts to be at the 'study level' because we wanted to account for variation due to e.g. when hosts were dissected. 

However, some studies had a single condition, such as 100 hosts each receiving 2 worm larva. The results of such an experiment may be reported as a mean abundance (i.e. worms per exposed host). From such results, we know the number of parasites given and the number recovered, but not their distribution among hosts. Such results are at the study level.

Logistic regression accounts for the number of trials (worms given) and the number of successes (worms recovered), so it should not matter that dataset is a mix of results at the host level and the study level - the trials do not change. Nonetheless, let's compare models fit at either level. We convert the dataframe to the 'condition' level. Any infections within a study using e.g. different host species, doses, or dissection times are kept separate, whereas any infection under the same conditions are pooled.

```{r}
## Should analysis be at level within study?
datx <- dat%>%
  group_by(Species, Study, nh_fac, to_int_def, log_dpi, Dose, Host_Species, Stage, tree_tips)%>%
  summarise(n_hosts = sum(Sample_Size),
            tot_given = sum(tot_given),
            tot_inf = sum(tot_inf),
            log_ws = mean(log_ws),
            log_hm = mean(log_hm),
            log_dose = mean(log_dose))%>%
  ungroup()%>%
  mutate(succeeded = tot_inf, failed = tot_given - tot_inf,
         Recovery_Rate = tot_inf/tot_given)
datx <- datx%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = factor(st_id, levels = c("1 Intermediate", "1 Definitive",
                                          "2 Intermediate", "2 Definitive",
                                          "3 Intermediate", "3 Definitive")))

datx <- mutate(datx, study_rs = factor(paste0(Study,":",nh_fac)))
datx <- mutate(datx, obs = 1:length(Species))%>%
  mutate(log_dpi_cen = log_dpi - log(14),
         log_dose_cen = log_dose - log(100))

```

Now we re-fit the logistic regression from above, but at the 'condition' level. We fit them with `lmer` since this is faster.

```{r}
library(lme4)
```
```{r}
m1 <- lme4::glmer(cbind(succeeded, failed) ~ log_dpi + nh_fac*to_int_def + log_ws + log_hm + 
                    (1|study_rs) + (1|obs),
                  data = filter(dat, !is.na(log_ws), !is.na(log_hm)),
                  family = "binomial")
# m1.1 <- update(m1, . ~ . + log_dose_cen + (1+log_dose_cen|study_rs))


m2 <- update(m1, data = filter(datx, !is.na(log_ws), !is.na(log_hm)))
# m2.1 <- update(m2, . ~ . + log_dose_cen + (1+log_dose_cen|study_rs) )
```

The fixed effect parameters are almost identical, even though the model in which rows were sometimes individual hosts have more "observations".

```{r}
qplot(lme4::fixef(m1), lme4::fixef(m2)) +
  geom_label(aes(label = names(lme4::fixef(m1)))) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  labs(x = paste("Parameters, mixed level, n = ", summary(m1)$devcomp$dims["n"] ),
       y = paste("Parameters, condition level, n = ", summary(m2)$devcomp$dims["n"] ))
```

The estimated SE associated with each term is also the same in the two models.

```{r}
qplot(summary(m1)$coefficients[,"Std. Error"],
      summary(m2)$coefficients[,"Std. Error"]) +
  geom_label(aes(label = names(lme4::fixef(m1)))) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  labs(x = paste("Parameter SE, mixed level, n = ", summary(m1)$devcomp$dims["n"] ),
       y = paste("Parameter SE, condition level, n = ", summary(m2)$devcomp$dims["n"] ))
```

The random effects are also very similar, but they differ in ways that we would expect. By pooling, the residual variance goes down because there are fewer points within studies. The between study variance also goes down slightly, presumably because pooling makes the study effects more variable.

```{r}
summary(m1)$varcor
summary(m2)$varcor
```

We can also compare the R^2^ of the two models.

```{r}
r2_glmm_tax <- function(model) {

  # model stuff
  call <- as.character(model@call)[2]
  X <- model.matrix(model)
  n <- nrow(X)
  Beta <- fixef(model)
  df <- length(Beta) - 1
  
  # variance due to fixed effects
  Sf <- var(X %*% Beta)
  
  # variance due to rand effects
  Sigma.list <- VarCorr(model)
  Sl <- 
    sum(
      sapply(Sigma.list["study_rs"], # not obs-level RE
        function(Sigma)
        {
          Z <-X[,rownames(Sigma)]
          sum(diag(Z %*% Sigma %*% t(Z)))/n
        }))
  Se <- Sigma.list$obs # additive error
  Sd <- pi^2/3 # dist-specific error
  total.var <- c(Sf + Sl + Se + Sd)
  mr2 <- c(Sf / total.var)
  cr2 <- c((Sf + Sl) / total.var)

  # output
  out_frame <- data_frame(call = call, df = df, 
                          VF = as.numeric(Sf), VR = as.numeric(Sl),
                          VD = as.numeric(Sd), VE = as.numeric(Se),
                          marg_r2 = round(mr2, 3), cond_r2 = round(cr2,3))
  return(out_frame)
}
```

They are similar, but pooling reduces the variance explained.

```{r}
r2_table <- rbind(r2_glmm_tax(m1), r2_glmm_tax(m2))

r2_table <- mutate(r2_table, study_var_explained = cond_r2 - marg_r2)
r2_table <- dplyr::select(r2_table,
                          VF, VR, VD, VE,
                          marg_r2, cond_r2, study_var_explained)
r2_table
```

Since we proceed mainly at the condition level, let's re-calculate some of the descriptive statistics. Number of recovery rates (rows):

```{r}
length(datx$Species)
```

Number of species:

```{r}
n_distinct(datx$Species)
```

Number of stages:

```{r}
n_distinct(paste(datx$Species, datx$nh_fac, datx$to_int_def))
```

Number of studies:

```{r}
n_distinct(datx$Study)
```

Total number of exposed hosts:

```{r}
sum(datx$n_hosts)
```
Proportion without worm size:

```{r}
sum(is.na(datx$log_ws))/length(datx$log_ws)
```

Proportion without host mass: 

```{r}
sum(is.na(datx$log_hm))/length(datx$log_hm)
```
Proportion without host or parasite size

```{r}
sum(is.na(datx$log_hm) | is.na(datx$log_ws))/length(datx$log_hm)
```

```{r}
# add host tax
datx <- mutate(datx, host_genus = substr(Host_Species, start = 1, stop = regexpr(" ", Host_Species)-1))

host_tax <- read.csv(file = "../../../lcl_host_types/data/ncbi_fishbase_eol_tax_combined.csv", header = T)
datx <- left_join(datx,
          select(host_tax, host_genus = genus, host_class = class)%>%distinct(),
          by = "host_genus")
ht <- data.frame(host_class = unique(datx$host_class),
                 host_type1 = c("mollusc", "mammal", "fish", "terr arth", "bird", "crustacean",
                                "crustacean", "annelid", "amphibian", "terr arth"))
ht <- ht%>%
  filter(!is.na(host_type1))%>%
  mutate(host_type2 = if_else(host_type1 %in% c("terr arth", "crustacean", "mollusc", "annelid"), "invertebrate",
                              if_else(host_type1 %in% c("reptile", "amphibian"), "herp", host_type1)))
datx <- left_join(datx, ht)

datx%>%
  group_by(host_type2)%>%
  summarize(number_exp_hosts = sum(n_hosts))

rm(ht, host_tax)
```

## Weights

Most experimental infections are based on single individuals, but some experiments report infection rates from groups of individuals.

```{r}
ggplot(dat, aes(x = Sample_Size)) + 
  scale_x_log10() +
  geom_histogram() 
```
```{r}
# ggplot(datx, aes(x = n_hosts)) + 
#   scale_x_log10() +
#   geom_histogram()
```

We would like to give experiments with multiple individuals more weight, but it is tricky to know how. Should an infection of 10 hosts have a 10-fold higher weight in the analysis than an infection with one animal? Or 2-fold, if on a log10 scale? Let's try weighting the analysis on a log-10 scale, and then we'll compare a non-phylogenetic model with and without weighting.

```{r}
dat <- mutate(dat, weights = log10(Sample_Size)+1)
datx <- mutate(datx, weights = log10(n_hosts)+1)
```

```{r}
m1w <- lme4::glmer(cbind(succeeded, failed) ~ log_dpi + nh_fac*to_int_def + log_ws + log_hm + 
                    (1|study_rs) + (1|obs),
                  data = filter(dat, !is.na(log_ws), !is.na(log_hm)),
                  weights = filter(dat, !is.na(log_ws), !is.na(log_hm))$weights,
                  family = "binomial")


m2w <- update(m2, weights = filter(datx, !is.na(log_ws), !is.na(log_hm))$weights)
```

The fixed effects are essentially identical in the models with or without weighting, either at the host and condition level.

```{r}
qplot(lme4::fixef(m1), lme4::fixef(m1w)) +
  geom_label(aes(label = names(lme4::fixef(m1)))) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  labs(y = paste("Parameters, weighted by log num hosts, n = ", summary(m1w)$devcomp$dims["n"] ),
       x = paste("Parameters, unweighted, n = ", summary(m1)$devcomp$dims["n"] ),
       title = "Host and condition level")
```

Or at the condition level. 

```{r}
qplot(lme4::fixef(m2), lme4::fixef(m2w)) +
  geom_label(aes(label = names(lme4::fixef(m2)))) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  labs(y = paste("Parameters, weighted by log num hosts, n = ", summary(m2w)$devcomp$dims["n"] ),
       x = paste("Parameters, unweighted, n = ", summary(m2)$devcomp$dims["n"] ),
       title = "Condition level")
```

The estimated SE associated with each term is also the same in the two models.

```{r}
qplot(summary(m1)$coefficients[,"Std. Error"],
      summary(m1w)$coefficients[,"Std. Error"]) +
  geom_label(aes(label = names(lme4::fixef(m1)))) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0) +
  labs(x = paste("Parameter SE, unweighted, n = ", summary(m1)$devcomp$dims["n"] ),
       y = paste("Parameter SE, weighted, n = ", summary(m1w)$devcomp$dims["n"] ))
```

Maybe weights have little impact because they are unrelated to recovery rate. Experiments given higher weights are not more likely to have a high or low recovery rate.

```{r}
ggplot(datx, aes(x = weights, y = Recovery_Rate, color = nh_fac)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = lm, se = T)
```

Given that (i) it is not clear how to weight by sample size and (ii) it doesn't affect the parameters, I proceed without weighting by sample size.

```{r}
# same model but with MCMCglmm
# priorW <- list(R=list(V=1, nu=0.002), 
#                G=list(G1=list(V=1, nu=0.002),
#                       G2=list(V=1, fix=1)))
# mod2w <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac*to_int_def + log_ws + log_hm, 
#                  random = ~ study_rs + idh(1/weights),
#                  prior = priorW,
#                  nitt = nit, thin = 20, burnin = bi,
#                  data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
#                  family = 'multinomial2', pr=T, 
#                  verbose = F)

# The fixed effects are essentially identical in the two models. 

# qplot(summary(mod2)$solutions[,1], summary(mod2w)$solutions[,1]) +
#   geom_label(aes(label = names(summary(mod2)$solutions[,1]))) +
#   geom_abline(slope = 1, intercept = 0) +
#   labs(x = "Parameter estimates, unweighted model", y = "Parameter estimates, weighted model")
```

## Random slopes

### Time of dissection 

We did not average at the study level, because there are some important sources of variation within studies, like different dissection times. In the previous models, we fit a single time-dependent decrease in recovery. This may be a little disingenuous because different parasite species or stages may be lost from hosts at different rates. Here is the relationship over the full data (infections pooled at condition level): 

```{r}
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm)),
       aes(x = exp(log_dpi), y = Recovery_Rate)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.2) +
  geom_smooth(method = lm, se = F) +
  geom_smooth(method = lm, formula = y ~ log(x), se = F, linetype = 'dashed') +
  labs(x = "Time (days post exposure)", y = "Recovery rate")
```

As expected, recovery rates go down with days post infection, but there is a lot of variation. Also, it is not clear that the relationship is linear. For example, the dashed line is the relationship with log time, which assume that hazards are exponential (i.e. they don't accumulate linearly).

Given that hosts were dissected on different time schedules in different studies, each study could have a different relationship with time. Here is a plot showing time-dependent recovery in 49 studies. We see that the relationship is usually linear, though sometimes the log relationship fits better (dashed lines). We can also see that sometimes there is a negative relationship, sometimes none, and sometimes a positive relationship.

```{r}
st <- filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
  group_by(Study)%>%summarise(n = n_distinct(log_dpi))%>%
  arrange(desc(n))%>%
  ungroup()%>%
  slice(1:49)%>%
  .$Study

ggplot(filter(datx, Study %in% st)%>%
         mutate(Study = factor(Study, levels=st)),
       aes(x = exp(log_dpi), y = Recovery_Rate, color = nh_fac)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.4) +
  geom_smooth(aes(group = study_rs), method = lm, se = F) +
  geom_smooth(aes(group = study_rs), method = lm, formula = y ~ log(x), se = F, linetype = 'dashed') +
  labs(x = "Time dpi", y = "Recovery Rate", 
       title = "Recovery over time within studies", 
       color = "Next Host", size = "Log num hosts") +
  facet_wrap(~Study, scales = 'free_x') +
  theme(axis.text.x = element_blank(),
        strip.text = element_blank(),
        panel.grid.minor = element_blank())
```

Thus, let's compare three models: 1) studies differ but have the same time effect (random intercepts), 2) study x time (random slopes), and 3) study x log time.

```{r}
# random intercepts
m2_r0l <- glmer(cbind(succeeded, failed) ~ + log_dpi +
                  (1|study_rs) + (1|obs),
                  data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                  family = "binomial")
m2_ri <- glmer(cbind(succeeded, failed) ~ exp(log_dpi) + nh_fac*to_int_def + log_ws + log_hm + 
                    (1|study_rs) + (1|obs),
                  data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                  family = "binomial")
m2_ril <- update(m2_ri, . ~ . + log_dpi - exp(log_dpi))

# random slopes
m2_rs0 <- glmer(cbind(succeeded, failed) ~ log_dpi + (1 + log_dpi|study_rs) + (1|obs),
                  data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                  family = "binomial")
m2_rs <- update(m2_ri, . ~ . + (1+exp(log_dpi)| study_rs) - (1 | study_rs))
m2_rsl <- update(m2_ril, . ~ . + (1+log_dpi| study_rs) - (1 | study_rs))
```

The random slopes model was a clear improvement, regardless whether time was untransformed...

```{r}
anova(m2_ri, m2_rs)
```

...or log transformed.

```{r}
anova(m2_ril, m2_rsl)
```

The random slopes model with log time was also a better fit than the model with untransformed time.

```{r}
anova(m2_rs, m2_rsl)
```

Calculating R^2^ values for random slope models is more complex than for random intercept models, because the variance explained by the random effects depends on the levels of the random effect (Study) *and* the covariate values (time). We modified code given [here](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12225) to calculate R^2^ for random slope models. We can see how the conditional R^2^ goes up as we include random slopes, though it does not increase further when we use with log time. The reason is that the overall error variance goes down when we use log time, but so does the variance between studies. This suggests that using log time better accounts for variation within studies, thereby reducing the differences between studies.

```{r}
mod_list <- list(m2_ri, m2_rs, m2_rsl)
if(exists("r2_table")){rm(r2_table)}
i <- 1
for(model in mod_list){
  if(i == 1){
    r2_table <- r2_glmm_tax(model)
  } else {
    r2_table <- rbind(r2_table, r2_glmm_tax(model))
  }
  i <- i + 1
}

r2_table <- mutate(r2_table, study_var_explained = cond_r2 - marg_r2, df_used = df - lag(df))
r2_table$step <- c("random int", "random slope", "random slope, log time")
r2_table <- dplyr::select(r2_table, step, df_used,
                          VF, VR, VD, VE,
                          marg_r2, cond_r2, study_var_explained)
r2_table
```

Here is the summary of the simplest random slopes model (i.e. just time, study, and their interaction). Interestingly, the fixed effect of dpi is only weakly negative. Both the random intercept term (studies differ in mean recovery) and the random slope term (studies differ in how recovery changes with time) are positive. The covariance tends to be negative, indicating that studies with above average recoveries tend to be associated with stronger decreases over time. Conversely, if recovery is low to begin with, then it has more of a chance to increase (positive slopes).

```{r}
summary(m2_rs0)
```

This plot shows how slopes and intercepts are negatively related at the level of study. This correlation, though, disappears when the time variable is centered (not shown).

```{r}
re <- ranef(m2_rs0)$study_rs
re$study_rs <- rownames(re)
re <- mutate(re, Study = substr(study_rs, start = 1, stop = nchar(study_rs)-2))%>%
  arrange(log_dpi)

qplot(re$`(Intercept)`, re$log_dpi) +
  geom_smooth(se = F, method = lm) +
  labs(title = "Random intercepts vs random slopes for studies", x = "Intercepts", y = "Slopes")
```

Since the random slopes model appears to be superior, let's check the predictions. Here are the random slope predictions within studies. The model seems to capture the relationships well.

```{r}
p <- boot::inv.logit(predict(m2_rs0, re.form = ~(1 + log_dpi|study_rs))) # preds from just RE

px <- cbind(filter(datx, !is.na(log_ws), !is.na(log_hm)),p)

ggplot(filter(px, Study %in% st)%>%
         mutate(Study = factor(Study, levels=unique(re$Study))),
       aes(x = exp(log_dpi), y = Recovery_Rate, color = nh_fac)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.4) +
  geom_line(aes(y = p, group = study_rs), linetype = "dashed", size = 1.5) +
  labs(x = "Time dpi", y = "Recovery Rate", 
       title = "Recovery over time within studies", 
       color = "Next Host", size = "Log num hosts") +
  facet_wrap(~Study, scales = 'free_x') +
  theme(axis.text.x = element_blank(),
        strip.text = element_blank(),
        panel.grid.minor = element_blank())
```

The number of studies where recovery increases looks similar to the number that decreases. Let's check each study individually. Here are the number of studies with at least 4 dissection times

```{r}
st_dpi <- filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
  group_by(study_rs)%>%summarise(n = n_distinct(log_dpi))%>%
  filter(n>3)%>%
  .$study_rs
length(st_dpi)
```

We fit a simple logistic regression to each one to test whether recovery usually increases or decreases over time.

```{r}
# make df with study-level dfs as list
df_st <- filter(datx, !is.na(log_ws), !is.na(log_hm), study_rs %in% st_dpi)%>%
  select(study_rs, succeeded, failed, log_dpi)%>%
  group_by(study_rs)%>%
  nest()

# function to fit logistic regression
mod_fun <- function(df){
  glm(cbind(succeeded, failed) ~ log_dpi, data = df, family = "binomial")
}

df_st <- df_st%>%
  mutate(model = map(data, mod_fun))

# function to extract slope coefficient
b_fun <- function(mod){
  coef(mod)[2]
}
# function extract p value
p_fun <- function(mod){
  summary(mod)$coefficients[2,"Pr(>|z|)"]
}

df_st <- df_st%>%
  transmute(study_rs, beta = map_dbl(model, b_fun), p = map_dbl(model, p_fun))%>%
  arrange(beta)%>%
  mutate(beta_dir = if_else(beta>0, "pos", "neg"), sig = p < 0.001)
```

Here's the distribution of regression coefficients.

```{r}
ggplot(df_st, aes(x = beta, fill = sig)) + geom_histogram()
```

There were more studies with negative coefficients than positive coefficients, but not many. Negative coefficients (decreased recover over time) were a bit more likely to be statistically significant (P < 0.001) than positive coefficients.

```{r}
df_st%>%
  group_by(beta_dir)%>%
  summarise(n=n(), sigs = sum(sig))%>%
  mutate(perc_sig = round(sigs/n, 3))
```

How quickly recovery decreases with time is not dependent on life stage, so e.g. recovery does not decrease faster for worms in the second host compared to the first host.

```{r}
ggplot(left_join(df_st, select(datx, study_rs, nh_fac, to_int_def)%>%distinct()),
       aes(x = beta, fill = sig)) + 
  geom_histogram() + 
  facet_grid(nh_fac~to_int_def)
```

One worry is if model fit varies with time post exposure, such as if there was systemic undercounting in early dissections. The residual plots across studies do not suggest that recovery rates are over- or underestimated at different dpi.

```{r}
ggplot(filter(px, Study %in% st)%>%
         mutate(Study = factor(Study, levels=unique(re$Study)),
                res = Recovery_Rate - p),
       aes(x = log_dpi, y = res, color = nh_fac)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.4) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  labs(x = "Log time", y = "Unstandardized residuals", title = "Model fit within studies", color = "Next Host") +
  facet_wrap(~Study, ncol = 7) +
  theme(strip.text = element_blank(),
        panel.grid.minor = element_blank()) 
```

Let's make some plots with CIs for the change in recovery with time. We'll use `MCMCglmm` to fit the models.

```{r}
# starting conditions from lmer
rs <- (lme4::VarCorr(m2_r0l)["study_rs"][[1]])
attributes(rs) <- NULL
startc <- list(R = as.numeric(lme4::VarCorr(m2_r0l)["obs"][[1]]),
               G = list(G1 = rs ),
               QUASI = FALSE)

# for MCMCglmm, need to add "missing" data, as new data for predictions
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm))

dxx <- (dx)%>%
  summarize(min_dpi = min(log_dpi, na.rm = T),
            max_dpi = max(log_dpi, na.rm = T))
dxy <- bind_rows(
  data.frame(Study = unique(dx$Study)[1],
             log_dpi = seq(dxx$min_dpi[1], dxx$max_dpi[1], length.out = 50))
  )
dxy$pred <- 'yes'
dx <- bind_rows(dx, dxy)
rm(dxx, dxy)

# refit model
modp1lp <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi, 
                 random = ~ study_rs,
                 prior = prior2,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=F, 
                 verbose = F)

p <- predict(modp1lp, 
             type = 'terms',
             interval = 'confidence',
             marginal = ~study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
```

Here is the overall decrease in recovery with time, as predicted by the random intercepts model.

```{r}
f1a <- ggplot(p,
              aes(x = exp(log_dpi), y = Recovery_Rate)) +
  geom_point(alpha = 0.2,
             aes(size = n_hosts)
             # position = position_jitter(width = 0.1)
             ) +
  geom_ribbon(data = filter(p, pred == "yes"),
              aes(x = exp(log_dpi), ymax = upr, ymin = lwr),
              alpha = 0.2) +
  geom_line(data = filter(p, pred == "yes"), 
            aes(x = exp(log_dpi), y = fit)) +
  labs(y = "Recovery rate",
       x = "Time of dissection\n(days post infection)",
       size = "Hosts exposed") +
  scale_x_log10(breaks = c(0.1, 1, 10, 100)) +
  scale_size_continuous(trans = "log10") +
  theme(panel.grid.minor = element_blank())
f1a
```

Here is the same plot but the predictions are from the random slopes model. They are similar, though the CI is wider in the random slopes model.

```{r}
# starting conditions from lmer
rs <- (lme4::VarCorr(m2_rs0)["study_rs"][[1]])
attributes(rs) <- NULL
rs <- matrix(rs, 2)
startc <- list(R = as.numeric(lme4::VarCorr(m2_rs0)["obs"][[1]]),
               G = list(G1 = rs ),
               QUASI = FALSE)
rm(rs)

# refit model
priorRS <- list(R = list(V = 1, nu = 0.002),
                G = list(G1 = list(V = diag(2), nu = 2))
                )
modp1_rsl <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=T, 
                 verbose = F)

p <- predict(modp1_rsl, 
             type = 'terms',
             interval = 'confidence',
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
```
```{r}
f1a <- ggplot(p,
              aes(x = exp(log_dpi), y = Recovery_Rate)) +
  geom_point(alpha = 0.2,
             # aes(size = n_hosts)
             # position = position_jitter(width = 0.1)
             ) +
  geom_ribbon(data = filter(p, pred == "yes"),
              aes(x = exp(log_dpi), ymax = upr, ymin = lwr),
              alpha = 0.2) +
  geom_line(data = filter(p, pred == "yes"), 
            aes(x = exp(log_dpi), y = fit)) +
  labs(y = "Recovery rate",
       x = "Time of dissection\n(days post infection)",
       size = "Hosts exposed") +
  scale_x_log10(breaks = c(0.1, 1, 10, 100)) +
  # scale_size_continuous(trans = "log10") +
  theme(panel.grid.minor = element_blank())
f1a
```


We can also pick a few studies for a manuscript figure that illustrates the different time by recovery relationships.

```{r}
p <- predict(modp1_rsl, 
             type = 'terms',
             interval = 'confidence',
             marginal = NULL
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
```
```{r}
# add re slopes for ordering plot 
px <- posterior.mode(modp1_rsl$Sol)
px <- data.frame(param = names(px), value = px, row.names = 1:length(px))
px1 <- filter(px, grepl(pattern = "\\(Intercept\\)\\.study_rs", param))
px2 <- filter(px, grepl(pattern = "log_dpi\\.study_rs", param))
px <- cbind(rename(px1, param1 = param, intercept = value),
            rename(px2, param2 = param, slope = value ))
p<-px%>%
  mutate(study_rs = gsub("log_dpi\\.study_rs\\.", replacement = "", param2))%>%
  select(-param1, -param2)%>%
  left_join(p, .)
```
```{r}
f1bcd <- ggplot(filter(p, Study %in% c("Litchford 1963 . J. Parasitol. 49 : 403-410", 
                              "Pybus and Samuel 1984 . J. Parasitol. 70 : 507-515",
                              "Audebert et al. 2002 . J. Parasitol. 88 : 898-904"))%>%
         mutate(Study = fct_reorder(Study, slope)), # order plot by random slope
       aes(x = exp(log_dpi), y = Recovery_Rate)) +
  geom_point(alpha = 0.2) +
  geom_line(aes(y = fit), linetype = "dashed") +
  geom_ribbon(aes(ymax = upr, ymin = lwr),
              alpha = 0.2) +
  scale_y_continuous(limits = c(0,1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  labs(y = "Recovery rate", x = "Time of dissection\n(days post infection)") +
  facet_wrap(~Study, ncol = 1, scales = 'free_x') +
  theme(strip.text = element_blank(),
        panel.grid.minor = element_blank()) 
f1bcd
```
```{r}
f1 <- cowplot::plot_grid(f1a, f1bcd, rel_widths = c(1.5, 1))
ggsave(f1, filename = "../../figs/fig1.png", width = 6, height = 4)
ggsave(f1, filename = "../../figs/fig1.svg", width = 6, height = 4)
```

### Dose

Another researcher-controlled variable that varied within studies was dose. Some studies used multiple doses. Recovery rates might increase with dose (e.g. more worms overwhelm immune responses) or decrease with dose (competition among parasites, increased immune response). Here's how the pattern looks across the studies with multiple doses. Often the relationship is flat or decreasing. And it is usually linear as log-transforming dose did not provide a better fit in most cases.

```{r}
st <- filter(dat, !is.na(biovolume), !is.na(host_bm))%>%
  group_by(study_rs)%>%summarise(n = n_distinct(Dose))%>%
  arrange(desc(n))%>%
  ungroup()%>%
  slice(1:36)%>%
  .$study_rs

ggplot(filter(datx, study_rs %in% st),
       aes(x = Dose, y = Recovery_Rate, color = nh_fac)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.4) +
  geom_smooth(aes(group = study_rs), method = lm, se = F) +
  geom_smooth(aes(group = study_rs), method = lm, formula = y ~ log(x), se = F, linetype = 'dashed') +
  labs(x = "Dose", y = "Recovery Rate", title = "Recovery over time within studies", color = "Next Host") +
  facet_wrap(~Study, scales = 'free_x', nrow = 6) +
  theme(axis.text.x = element_blank(),
        strip.text = element_blank(),
        panel.grid.minor = element_blank())
```

However, across the whole data dose varies by several orders of magnitude, so a linear relationship (solid line) does not fit the data well. Dose probably needs to be log-transformed for analyses. 

```{r}
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm)),
       aes(x = Dose, y = Recovery_Rate)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.2) +
  geom_smooth(method = lm, formula = y ~ (x), se = F, linetype = 'solid') +
  geom_smooth(method = lm, formula = y ~ log(x), se = F, linetype = 'dashed') +
  labs(x = "Dose", y = "Recovery rate") +
  # scale_x_log10() +
  coord_cartesian(ylim = c(0,1))
```

Here is the same plot, but with the x-axis log transformed. The relationship between recovery and log dose (dashed line) fits better. Higher doses are associated with lower recovery. This suggests that researchers use higher doses when lower recovery rates are expected *OR* that higher doses cause lower recovery. 

```{r}
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm)),
       aes(x = Dose, y = Recovery_Rate)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.2) +
  geom_smooth(method = lm, formula = y ~ exp(x), se = F, linetype = 'solid') +
  geom_smooth(method = lm, formula = y ~ (x), se = F, linetype = 'dashed') +
  labs(x = "Dose", y = "Recovery rate") +
  scale_x_log10() +
  coord_cartesian(ylim = c(0,1))
```

At least within studies, higher doses seem to cause lower recovery. The red lines on the next plot are the fits for each study and they are often negative.

```{r}
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm)),
       aes(x = Dose, y = Recovery_Rate)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.2) +
  geom_smooth(data = filter(datx, study_rs %in% st),
              aes(group = study_rs),
              method = lm, formula = y ~ (x), se = F, color = 'red') +
  labs(x = "Dose", y = "Recovery rate") +
  scale_x_log10() +
  coord_cartesian(ylim = c(0,1))
```

Given the broad range of doses, it is probably better to use log dose in the analyses. For example, when we add untransformed dose as a fixed effect to the random-intercpt model we fitted above, the effect is weak.

```{r}
m2_rid <- update(m2_ril, . ~ . + Dose)
anova(m2_ril, m2_rid)
```

But it is very clear with log-transformed dose.

```{r}
m2_rild <- update(m2_ril, . ~ . + log_dose)
anova(m2_ril, m2_rild)
```

A random slopes model with untransformed dose also has numerical issues with fitting, so I continue with log dose.

```{r}
# m2_rsd <- update(m2_rid, . ~ . + (1+Dose| study_rs) - (1 | study_rs)) # does not fit
```

Let's compare three models: 1) studies differ but have the same dose relationship (random intercepts), 2) study x dose (random slopes), and 3) with both random slopes terms (dose and dpi).

```{r}
m2_rs0d <- glmer(cbind(succeeded, failed) ~ 1 + (1 + log_dose|study_rs) + (1|obs),
                  data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                  family = "binomial")

m2_rsd <- update(m2_rild, . ~ . + (1+log_dose|study_rs) - (1 | study_rs))
m2_rs2 <- update(m2_rsd, . ~ . + (log_dose+log_dpi|study_rs)-(1+log_dose|study_rs))
```

Adding a dose random slopes term to a random intercept model is an improvement...

```{r}
anova(m2_rild, m2_rsd)
```

...as is adding the dose random slopes term to a model that already includes a random slopes term for time dpi.

```{r}
anova(update(m2_rsl, . ~ . + log_dose), # add fixed dose effect so LRT is just for random effect
      m2_rs2)
```

The main effect of dose explains about 4% of variation in recovery, whereas the random slopes explains just 1-2%. By contrast, dissection time random effect explains more of the variation within studies (~10%). This suggests that studies with different recovery rates use different doses and that dose explains relatively little variation within studies.

```{r}
mod_list <- list(m2_ril, m2_rild, m2_rsd, m2_rs2)
if(exists("r2_table")){rm(r2_table)}
i <- 1
for(model in mod_list){
  if(i == 1){
    r2_table <- r2_glmm_tax(model)
  } else {
    r2_table <- rbind(r2_table, r2_glmm_tax(model))
  }
  i <- i + 1
}

r2_table <- mutate(r2_table, study_var_explained = cond_r2 - marg_r2, df_used = df - lag(df))
r2_table$step <- c("random int, without dose", "random int, dose main effect", 
                   "random slope for dose", "two random slopes, dose and time")
r2_table <- dplyr::select(r2_table, step, df_used,
                          VF, VR, VD, VE,
                          marg_r2, cond_r2, study_var_explained)
r2_table
```

Let's check the predictions. Here are the predicted recoveries given the study by dose interaction (no fixed effects). They look good, but it is also clear that these relationships vary less than the study x time relationships.

```{r}
re <- ranef(m2_rs0d)$study_rs
re$study_rs <- rownames(re)
re <- mutate(re, Study = substr(study_rs, start = 1, stop = nchar(study_rs)-2))%>%
  arrange(log_dose)
```
```{r}
p <- boot::inv.logit(predict(m2_rs0d, re.form = ~(1 + log_dose|study_rs))) # preds from just RE

px <- cbind(filter(datx, !is.na(log_ws), !is.na(log_hm)),p)

ggplot(filter(px, study_rs %in% st)%>%
         mutate(Study = factor(Study, levels=unique(re$Study))),
       aes(x = log_dose, y = Recovery_Rate, color = nh_fac)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.4) +
  geom_line(aes(y = p, group = study_rs), linetype = "dashed", size = 1.5) +
  labs(x = "Dose", y = "Recovery Rate", 
       title = "Recovery over time within studies", 
       color = "Next Host", size = "Log num hosts") +
  facet_wrap(~Study, scales = 'free_x') +
  theme(axis.text.x = element_blank(),
        strip.text = element_blank(),
        panel.grid.minor = element_blank())
```

Like we did for dissection times, let's fit a logistic regression to each study with at least 4 different doses. There are only 27 of these studies.

```{r}
st_dpi <- filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
  group_by(study_rs)%>%summarise(n = n_distinct(log_dose))%>%
  filter(n>4)%>%
  .$study_rs
length(st_dpi)
```

We fit a simple logistic regression to each one to test whether recovery usually increases or decreases over time.

```{r}
# make df with study-level dfs as list
df_st <- filter(datx, !is.na(log_ws), !is.na(log_hm), study_rs %in% st_dpi)%>%
  select(study_rs, succeeded, failed, log_dose)%>%
  group_by(study_rs)%>%
  nest()

# function to fit logistic regression
mod_fun <- function(df){
  glm(cbind(succeeded, failed) ~ log_dose, data = df, family = "binomial")
}

df_st <- df_st%>%
  mutate(model = map(data, mod_fun))

# function to extract slope coefficient
b_fun <- function(mod){
  coef(mod)[2]
}
# function extract p value
p_fun <- function(mod){
  summary(mod)$coefficients[2,"Pr(>|z|)"]
}


df_st <- df_st%>%
  transmute(study_rs, beta = map_dbl(model, b_fun), p = map_dbl(model, p_fun))%>%
  arrange(beta)%>%
  mutate(beta_dir = if_else(beta>0, "pos", "neg"), sig = p < 0.001)
```

Here's the distribution of regression coefficients. There's a negative skew.

```{r}
ggplot(df_st, aes(x = beta, fill = sig)) + geom_histogram()
```

There were twice as many studies with negative coefficients than positive coefficients, and they were much more likely to be considered significant (P < 0.001).

```{r}
df_st%>%
  group_by(beta_dir)%>%
  summarise(n=n(), sigs = sum(sig))%>%
  mutate(perc_sig = round(sigs/n, 3))
```

So dose explains some variation within studies, but much less than dissection time. And dose seems to explain a fair amount of the differences between studies. However, this is also the main variation we are trying to parse. I think that doses are chosen in response to different recovery rates by researchers, not the other way around (i.e. using high doses is not why recovery rates are lower).

Since dose is incorporated into the response variable and since it probably does not cause the large variation across studies by itself, I leave it out of the main models, but consider it again at the end of the notebook.

## Phylogenetic model

Now let's add phylogeny into the model. We fit `MCMCglmm` models because it can incorporate phylogeny as random effects (phylogenetic covariance matrix). We want to assess whether phylogeny accounts for variation beyond study, since studies are usually on one species or a few closely related species. 

But first, let's compare the 3 major helminth groups to see if the main trends (shown later) are robust across taxa.

```{r}
datx<-left_join(datx, 
                select(dat, Species, parasite_genus, parasite_family,
                       parasite_order, parasite_class, parasite_phylum)%>%distinct())
```

Recovery increases with life cycle progression, though in acanths and cestodes establishment in the third host is not necessarily better than in the second host.

```{r}
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm)),
       aes(x = nh_fac, y = Recovery_Rate, color = nh_fac)) + 
  geom_boxplot(outlier.colour = NA) +
  geom_jitter(alpha = 0.2) +
  facet_wrap(~parasite_phylum) +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  guides(color = FALSE) +
  labs(x = "host in cycle")
```
In all groups, establishment increases with worm size.

```{r}
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm)),
       aes(x = log_ws, y = Recovery_Rate)) + 
  geom_point(alpha = 0.2, aes(color = nh_fac)) + 
  geom_smooth(se = T, method = lm, color = "black") +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  guides(color = FALSE) +
  labs(x = "Log worm size") +
  facet_wrap(~parasite_phylum)
```
And there was a weak tendency for establishment to decrease with host size within life stages but not across them.

```{r}
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm)),
       aes(x = log_hm, y = Recovery_Rate, color = nh_fac)) + 
  geom_point(alpha = 0.2) + 
  geom_smooth(se = T, method = lm) +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  guides(color = FALSE) +
  labs(x = "Log host size") +
  facet_wrap(~parasite_phylum)
```

So it does not look like there are big effects at the highest taxonomic level. Now we'll add phylogeny to the model three ways: 1) by itself, 2) to a model with just the study effect, and 3) to a model with study and the main fixed effects. This tests whether phylogeny explains variation alone, beyond study, and beyond life cycle characteristics, respectively. 

```{r}
final.tree<-makeNodeLabel(tree) # standardize node labels
Ainv <- inverseA(final.tree)$Ainv # make inv of phy cov matrix
```
```{r}
# just phylogeny model
rs <- (lme4::VarCorr(m2_r0l)["study_rs"][[1]])
attributes(rs) <- NULL
startc <- list(R = as.numeric(lme4::VarCorr(m2_r0l)["obs"][[1]]),
               G = list(G1 = rs ),
               QUASI = FALSE)

modp <- MCMCglmm(cbind(succeeded, failed) ~ 1, 
                 random = ~ tree_tips,
                 prior = prior2,
                 start = startc,
                 nitt = nit, thin = 40, burnin = bi,
                 data = as.data.frame(filter(datx, !is.na(log_ws), !is.na(log_hm))),
                 ginverse=list(tree_tips=Ainv),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
# phylogeny plus rs
rs <- (lme4::VarCorr(m2_rs0)["study_rs"][[1]])
attributes(rs) <- NULL
rs <- matrix(rs, 2)
startc <- list(R = as.numeric(lme4::VarCorr(m2_rs0)["obs"][[1]]),
               G = list(G1 = rs,
                        G2 = rs[1]),
               QUASI = FALSE)

priorRSP <- list(R = list(V = 1, nu = 0.002),
                G = list(G1 = list(V = diag(2), nu = 2),
                         G2 = list(V = 1, nu = 0.002))
                )
modp_rs <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi, 
                 random = ~ us(1+log_dpi):study_rs + tree_tips,
                 prior = priorRSP,
                 start = startc,
                 nitt = nit, thin = 40, burnin = bi,
                 data = as.data.frame(filter(datx, !is.na(log_ws), !is.na(log_hm))),
                 ginverse = list(tree_tips=Ainv),
                 family = 'multinomial2', pr=F, 
                 verbose = F)

# phylogeny plus fixed effects
startc <- list(R = as.numeric(lme4::VarCorr(m2_rs0)["obs"][[1]]),
               G = list(G1 = rs),
               QUASI = FALSE)
mod_rs_fe <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac + log_ws + log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 40, burnin = bi,
                 data = as.data.frame(filter(datx, !is.na(log_ws), !is.na(log_hm))),
                 ginverse = list(tree_tips=Ainv),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
startc <- list(R = as.numeric(lme4::VarCorr(m2_rs0)["obs"][[1]]),
               G = list(G1 = rs,
                        G2 = rs[1]),
               QUASI = FALSE)
modp_rs_fe <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac + log_ws + log_hm, 
                 random = ~ us(1+log_dpi):study_rs + tree_tips,
                 prior = priorRSP,
                 start = startc,
                 nitt = nit, thin = 40, burnin = bi,
                 data = as.data.frame(filter(datx, !is.na(log_ws), !is.na(log_hm))),
                 ginverse = list(tree_tips=Ainv),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```

When we compare models with DIC, we find that a model with just a phylogenetic effect is not clearly better than one with just a study effect (random intercept).

```{r}
cat("delta DIC, study-only (random intercept) vs phylogeny-only model:", round(modp1lp$DIC - modp$DIC, 2), "(higher is better)")
```

Adding phylogeny to the random slopes model is also not an obvious improvement

```{r}
cat("delta DIC, study-only (random slopes) vs phylogeny+random slopes:", round(modp1_rsl$DIC - modp_rs$DIC, 2), "(higher is better)")
```

And here's what happens when we add phylogeny to the model with several fixed effects (stage, worm and host size).

```{r}
cat("delta DIC, without vs with phylogeny when fixed effects in model:", round(mod_rs_fe$DIC - modp_rs_fe$DIC, 2), "(higher is better)")
```

In the phylogeny-only model, the phylogeny variance component is very large relatively to the residual variance, it is almost certainly inflated. Maybe some branches are associated with complete separation (100% recovery rates).

```{r}
plot(modp$VCV)
```
When we add phylogeny to the random slopes model, it is much lower and not clearly different from zero, either without fixed effects...

```{r}
plot(modp_rs$VCV[,"tree_tips"])
```

...or with fixed effects.

```{r}
plot(modp_rs_fe$VCV[,"tree_tips"])
```

The phylogenetic effect competes with the study effect - when we add phylogeny to a model with just study (random intercept) their variance components are negatively correlated (not shown). This makes sense. A given study usually focused on a single parasite species, so phylogeny and study should explain some of the same variation. 

One way to check this is to see whether 1 study corresponds to 1 species.

```{r}
dp <- datx%>%
  group_by(Species)%>%
  summarise(n_studies = n_distinct(Study))%>%
  arrange(desc(n_studies))
 # round(sum(dp$n_studies == 1)/length(dp$n_studies) * 100, 1)
```

Most species (`r round(sum(dp$n_studies == 1)/length(dp$n_studies) * 100, 1)`%) were represented by a single study, but for `r sum(dp$n_studies > 1)` species, recovery rates were obtained from multiple studies.

```{r}
dp2 <- datx%>%
  group_by(Species, nh_fac)%>%
  summarise(n_studies = n_distinct(Study))%>%
  arrange(desc(n_studies))
# dp2
# round(sum(dp2$n_studies == 1)/length(dp2$n_studies) * 100, 1)
```

An even higher percent of life stages (`r round(sum(dp2$n_studies == 1)/length(dp2$n_studies) * 100, 1)`%) were represented by a single study, suggesting some species have multiple studies in the data because the different studies cover different life stages.

Therefore, we would expect models that use species as the random effect to be very comparable to models with study as the random effect. To check, we fit models with just a study or species random effect (no fixed effects) and then calculate how much variation is explained by each.
```{r}
datx <- datx%>%
  mutate(spst = paste(Species, nh_fac))
```
```{r}
m1 <- glmer(cbind(succeeded, failed) ~ 1 + (1 | study_rs) + (1|obs),
            data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
            family = "binomial")
m2 <- update(m1, . ~ . + (1|Species) - (1 | study_rs))
m2.1 <- update(m1, . ~ . + (1|spst) - (1 | study_rs))
m3 <- update(m1, . ~ . + (1|Species))
m3.1 <- update(m1, . ~ . + (1|spst))
```

Study alone explained more variation than species alone.

```{r}
Sigma <- VarCorr(m1)
cat("Variance explained by study:", round(Sigma$study_rs/(Sigma$study_rs + Sigma$obs + pi^2/3) , 2),"\n" )
Sigma <- VarCorr(m2)
cat("Variance explained by species:", round(Sigma$Species/(Sigma$Species + Sigma$obs + pi^2/3) , 2) )
```
This makes sense because different stages from the same species can have quite different establishment rates and experiments with different stages are usually from different studies. When we use the combination of species and stage, the variance explained increases, but it is still less than study alone.

```{r}
Sigma <- VarCorr(m2.1)
cat("Variance explained by species-stage:", round( (Sigma$spst)/(Sigma$spst + Sigma$obs + pi^2/3) , 2) )
```
When we add species or species-stage to the study-only model, the explained variance increases only slightly, suggesting species does not explain much variation beyond that accounted for by study.

```{r}
Sigma <- VarCorr(m3)
cat("Variance explained by study and species together:",
    round( (Sigma$Species + Sigma$study_rs)/
             (Sigma$Species + Sigma$study_rs + Sigma$obs + pi^2/3) , 2),"\n" )
Sigma <- VarCorr(m3.1)
cat("Variance explained by study and species-stage together:",
    round( (Sigma$spst + Sigma$study_rs)/
             (Sigma$spst + Sigma$study_rs + Sigma$obs + pi^2/3) , 2) )
```
Surprisingly, though, the likelihood ratio test comparing a "study" model and a "study + species-stage" model was significant, suggesting that the multiple studies from a given species might be consistent. 

```{r}
anova(m1,m3.1)
```
Here is an attempt to plot this result. The plot shows the life stages, for which there were multiple studies in the data. The smaller black points are the recovery rates from within each study (e.g., different time points post infection), whereas the larger blue points are the average recovery rate for a study. Sometimes the points cluster (indicating a species identity effect) but sometimes they do not (implying a study effect).

```{r}
spp_mult <- datx%>%
  group_by(spst)%>%
  summarise(n_studies = n_distinct(Study))%>%
  arrange(desc(n_studies))%>%
  filter(n_studies > 1)%>%
  .$spst
dp3 <- datx%>%
  filter(spst %in% spp_mult)%>%
  group_by(spst, study_rs)%>%
  summarise(Recovery_Rate = mean(Recovery_Rate))
ggplot(filter(datx, spst %in% spp_mult)%>%
         mutate(spst = fct_reorder(spst, Recovery_Rate)),
       aes(x = spst, y = Recovery_Rate)) + 
  geom_point(size = 1) +
  geom_point(data = dp3, color = "blue", size = 2.5, alpha = 0.5) +
  coord_flip() +
  theme(panel.grid.minor = element_blank()) +
  labs(x = NULL, y = "Recovery rate")
```

Some of the similarity among life stages across studies is probably due to a stage's characteristics, like parasite size and host size. Therefore, let's again add species, but now to a model with fixed effects like time post infection, stage, worm size, and host size.

```{r}
m1_fe <- glmer(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def + log_ws + log_hm +
              (1 | study_rs) + (1|obs),
            data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
            family = "binomial")
m3_fe.1 <- update(m1_fe, . ~ . + (1|spst))
```

As before, species identity does not explain much (residual) variation beyond stage.

```{r}
Sigma <- VarCorr(m1_fe)
cat("Variance explained by study:", round(Sigma$study_rs/(Sigma$study_rs + Sigma$obs + pi^2/3) , 2),"\n" )
Sigma <- VarCorr(m3_fe.1)
cat("Variance explained by study and species-stage together:",
    round( (Sigma$spst + Sigma$study_rs)/
             (Sigma$spst + Sigma$study_rs + Sigma$obs + pi^2/3) , 2) )
```
Yet adding it still improves the model slightly.

```{r}
anova(m1_fe,m3_fe.1)
```
We would expect fixed effects to explain some of the differences between species, so we expect the variance component for species to decrease. Indeed it does.

```{r}
Sigma <- VarCorr(m3.1)
Sigma2 <- VarCorr(m3_fe.1)
cat("Variance component for species-stage without fixed effects:", round(Sigma$spst, 3),"\n" ,
    "Variance component for species-stage with fixed effects:", round(Sigma2$spst, 3),"\n",
    "Percent decrease:", round(1 - Sigma2$spst/Sigma$spst, 2))
```
By contrast, the study effect decreased much less.

```{r}
cat("Variance component for study without fixed effects:", round(Sigma$study_rs, 3),"\n",
    "Variance component for study with fixed effects:", round(Sigma2$study_rs, 3),"\n",
    "Percent decrease:", round(1 - Sigma2$study_rs/Sigma$study_rs, 2))
```
Thus, much of the consistency in establishment across studies for a given species is explained by things like host number, worm size, etc. We should keep this in mind for the phylogenetic models, which also include 'species' as the tips of the phylogeny. Returning to the phylogenetic models...

Let's compare R^2^ values for the models with and without phylogeny.

```{r}
# function to return R2 from models
r2_univ_binom <- function(m){
  
  varD <- (pi^2)/3 # distribution specific variance
  
  sol <- m$Sol # fix param
  vcv <- m$VCV # vc
  X <- m$X # design matrix
  num_fe <- m$Fixed$nfl # fixed effects
  l <- dim(X)[1] # number of data points in model

  # calculate fixed effects var
  p_all <- as.matrix(X) %*% t(sol[,1:num_fe]) # predicteds for every post sample
  f1 <- apply(p_all, MARGIN = 2, FUN = var)
  
  # random effects var
  resi <- which(grepl(colnames(vcv), pattern = 'units')) # remove resid variance from variance components
  randVar <- as.matrix(vcv[,-resi])
  ran1 <- if(dim(randVar)[2]>1){
    rowSums(randVar)
  } else {
    randVar
  }
  
  # resid var
  res1 <- vcv[, resi]
  
  # calculate R2 marginal
  r2m1 <- f1/(f1 + ran1 + res1 + varD)
  # for output...
  r2m1 <- paste0(round(median(r2m1),3), ' [', 
         round(quantile(r2m1, probs = 0.025), 3), '-', 
         round(quantile(r2m1, probs = 0.975), 3), ']')
  
  # calculate R2 conditional
  r2c1 <- (f1 + ran1)/(f1 + ran1 + res1 + varD)
  r2c1 <- paste0(round(median(r2c1),3), ' [', 
         round(quantile(r2c1, probs = 0.025), 3), '-', 
         round(quantile(r2c1, probs = 0.975), 3), ']')

  out_d <- data.frame(r2m = c(r2m1),
                      r2c = c(r2c1))
  return(out_d)
}
```
```{r}
# # adjust R2 function for random slopes models
r2_univ_binom_rs <- function(m){
  
  varD <- (pi^2)/3 # distribution specific variance

  sol <- m$Sol # fix param
  vcv <- m$VCV # vc
  X <- m$X # design matrix
  num_fe <- m$Fixed$nfl # fixed effects
  l <- dim(X)[1] # number of data points in model


  # calculate fixed effects var
  p_all <- as.matrix(X) %*% t(sol[,1:num_fe]) # predicteds for every post sample
  f1 <- apply(p_all, MARGIN = 2, FUN = var)


  # random effects var
  resi <- which(grepl(colnames(vcv), pattern = 'units')) # remove resid variance from variance components
  
  rs <- which(grepl(colnames(vcv), pattern = '.study_rs')) # get rand slope vc
  randVar <- as.matrix(vcv[,rs]) # rand slope vc
  rs_vars <- unique(substring(colnames(randVar),
                              first = 1,
                              last = regexpr(":", colnames(randVar))-1)) # extract names of rs vars
  Z <- as.matrix(X[,rs_vars]) # design matrix for rand effx
  randVar_df <- as.data.frame(randVar) # convert to data frame, make covar matrix into variable
  names(randVar_df) <- c("int", "cov1", "cov2", "slope")
  randVar_df <- randVar_df%>%
    rowwise()%>%
    mutate(cov_mat = list(matrix(c(int, cov1, cov2, slope), nrow = 2)))
  # use vector of cov matrices to calc random eff var
  ran1 <- purrr::map_dbl(randVar_df$cov_mat,
                         #see https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12225
                         function(x) {sum(diag(Z %*% x %*% t(Z)))/l}
                         )
  # extract any other random effects that are not random slopes
  ran2 <- as.matrix(vcv[,-c(rs,resi)])
  ran2 <- if(dim(ran2)[2]>1){
    as.matrix(rowSums(ran2))
  } else {
    ran2
  }
  ran1 <- if(dim(ran2)[2]>0){ # if none just use rs var, otherwise sum them
    ran1 + ran2
  } else {
    ran1
  }

  # resid var
  resi <- which(grepl(colnames(vcv), pattern = 'units')) # remove resid variance from variance components
  res1 <- vcv[, resi]

  # calculate R2 marginal
  r2m1 <- f1/(f1 + ran1 + res1 + varD)
  # for output...
  r2m1 <- paste0(round(median(r2m1),3), ' [',
         round(quantile(r2m1, probs = 0.025), 3), '-',
         round(quantile(r2m1, probs = 0.975), 3), ']')

  # calculate R2 conditional
  r2c1 <- (f1 + ran1)/(f1 + ran1 + res1 + varD)
  r2c1 <- paste0(round(median(r2c1),3), ' [',
         round(quantile(r2c1, probs = 0.025), 3), '-',
         round(quantile(r2c1, probs = 0.975), 3), ']')

  out_d <- data.frame(r2m = c(r2m1),
                      r2c = c(r2c1))
  return(out_d)
}
```

Weirdly, the R^2^ table suggests phylogeny alone has a huge effect compared to study alone (with or without random slopes). This is due to the very large variance component for the phylogenetic effect.

```{r}
m0 <- r2_univ_binom(modp1lp)
m1 <- r2_univ_binom(modp)
m2 <- r2_univ_binom_rs(modp1_rsl)
m3 <- r2_univ_binom_rs(modp_rs)
m4 <- r2_univ_binom_rs(mod_rs_fe)
m5 <- r2_univ_binom_rs(modp_rs_fe)

m0$model <- 'study only, random int'
m1$model <- "phylogeny only"
m2$model <- "study only, rand slopes"
m3$model <- 'rand slopes + phylogeny'
m4$model <- "random slopes + fixed effects"
m5$model <- "random slopes + fixed effects + phylogeny"
```
```{r}
r2_table <- bind_rows(m0, m2, m1)%>%
  select(model, r2m, r2c)
r2_table
```

This seeming importance of phylogeny disappears when we add it to a model with random slopes. It explains little variation beyond that explained by the study effect.

```{r}
r2_table <- bind_rows(m2, m3)%>%
  select(model, r2m, r2c)
r2_table
```

Phylogeny might account for some variation beyond that explained by study in a model with multiple fixed effects. However, this phylogenetic effect bordered zero.

```{r}
r2_table <- bind_rows(m4, m5)%>%
  select(model, r2m, r2c)
r2_table
```

I would not actually predict a strong phylogenetic effect, because different life stages from closely related species might have very different infection probabilities. Also, recovery rates are variable and measured with considerable error, making phylogenetic effects harder to detect. 

Since "study" and "species" overlap substantially, maybe we should just look at higher taxonomic levels. Since studies usually focus on the same species, maybe we can detect taxonomic/phyla effects by looking at whether e.g. parasite families have similar recovery rates across studies. To test this, we replace parasite phylogeny with taxonomy in the model, but only the higher taxonomic levels (i.e. phylum, class, order, and family - presumably those levels won't overlap much with the study effect). 

```{r}
start_tax <- list(R = as.numeric(lme4::VarCorr(m2_rs0)["obs"][[1]]),
                  G = list(G1 = rs,
                           G2 = rs[1]/4,
                           G3 = rs[1]/4,
                           G4 = rs[1]/4,
                           G5 = rs[1]/4),
                  QUASI = FALSE)

prior_tax <- list(R=list(V=1, nu=0.002), 
               G=list(G1=list(V = diag(2), nu = 2),
                      G2=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000),
                      G3=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000),
                      G4=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000),
                      G5=list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000))) # parameter expanded prior for tax effect
                      # G2=list(V=1, nu=0.002)))

modpt <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac + log_ws + log_hm, 
                 random = ~ us(1+log_dpi):study_rs +
                   parasite_phylum + parasite_class + parasite_order + parasite_family,
                 prior = prior_tax,
                 start = start_tax,
                 nitt = nit, thin = 40, burnin = bi,
                 data = as.data.frame(filter(datx, !is.na(log_ws), !is.na(log_hm))),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```

When we fit that model, we see that the taxonomic effects are usually near zero. This suggests species from the same order, family, etc. do not have more similar recovery rates than we would expect.

```{r}
plot(modpt$VCV[,5:8])
```

Here is the change in DIC when adding taxonomy to a model with fixed effects.

```{r}
cat("delta DIC, random slopes&fixed effx vs +taxonomy:", round(mod_rs_fe$DIC - modpt$DIC, 2), "(higher is better)")
```

And the R^2^ values goes up when we add taxonomy, though the conditional R^2^ has a wide range because the taxonomic effects were hard to estimate.

```{r}
m6 <- r2_univ_binom_rs(modpt)
m6$model <- "random slopes + fixed effects + taxonomy"
```
```{r}
r2_table <- bind_rows(m4, m6)%>%
  select(model, r2m, r2c)
r2_table
```

When we fit the taxonomic model with `lmer` and then perform a likelihood ratio test to see if adding taxonomy improves the model, it is not significant.

```{r}
m2_rs_tax <- update(m2_rsl, . ~ . + (1|parasite_family) + (1|parasite_order) + (1|parasite_class) + (1|parasite_phylum))
anova(m2_rsl,m2_rs_tax)
```

The variance components for study and most higher taxonomic levels are uncorrelated, with the exception of parasite family (some studies might be the only ones on a particular worm family). This suggests the negative correlation between study and phylogenetic effects in the previous models is due to the same species/genera being studied.

```{r}
round(autocorr(modpt$VCV)[1,,],2)
```

Here's a plot showing how the VC estimates for parasite order are unrelated to those for study.

```{r}
qplot(modpt$VCV[,'parasite_order'], modpt$VCV[,'(Intercept):(Intercept).study_rs']) +
  geom_smooth(se = F) +
  labs(x = "VC for parasite order", y = "VC for study", title = "Correlation between MCMC iterations")
```

We can also make a plot to confirm that recovery rates do not vary with taxonomy. Let's look at parasite families. The black points are observed recovery rates, while the red points are the medians for the family. It looks like some families might have higher infection rates than others, but recall that these may be single studies.

```{r}
f_avg <- filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
  group_by(parasite_phylum, parasite_family, Stage)%>%
  summarise(Recovery_Rate = median(Recovery_Rate))%>%
  arrange(Recovery_Rate)
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
         mutate(parasite_family = factor(parasite_family, levels = unique(f_avg$parasite_family))),
       aes(x = parasite_family, y = Recovery_Rate)) +
  geom_point(alpha = 0.2) +
  geom_point(data = f_avg, color = "red", size = 2.5) +
  theme(panel.grid.minor = element_blank()) +
  coord_flip() +
  facet_grid(parasite_phylum~Stage, space = "free_y", scales = "free_y") 
```

When we take the average recovery for a study, then the differences among parasite families are much less conspicuous.

```{r}
ggplot(filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
         mutate(parasite_family = factor(parasite_family, levels = unique(f_avg$parasite_family)))%>%
         group_by(parasite_phylum, parasite_family, Stage, study_rs)%>%
         summarize(Recovery_Rate = sum(tot_inf)/sum(tot_given)),
       aes(x = parasite_family, y = Recovery_Rate)) +
  geom_point(alpha = 0.2) +
  # geom_point(data = f_avg, color = "red", size = 2.5) +
  theme(panel.grid.minor = element_blank()) +
  coord_flip() +
  facet_grid(parasite_phylum~Stage, space = "free_y", scales = "free_y") 
```

When we make the same plot for parasite orders, which is less confounded with "study", we see few compelling differences.

```{r}
f_avg <- filter(dat, !is.na(biovolume), !is.na(host_bm))%>%
  group_by(parasite_phylum, parasite_order, Stage)%>%
  summarise(Recovery_Rate = median(Recovery_Rate))%>%
  arrange(Recovery_Rate,Stage)
ggplot(filter(dat, !is.na(biovolume), !is.na(host_bm))%>%
         mutate(parasite_order = factor(parasite_order, levels = unique(f_avg$parasite_order))),
       aes(x = parasite_order, y = Recovery_Rate)) +
  geom_point(alpha = 0.1) +
  geom_point(data = f_avg, color = "red", size = 2.5) +
  theme(panel.grid.minor = element_blank()) +
  coord_flip() +
  facet_grid(parasite_phylum~Stage, space = "free_y", scales = "free_y") 
```

What about the fixed effects? Are they the same with or without a phylogenetic random effect? They are rather tightly correlated, suggesting that a model with or without phylogeny will not impact the conclusions.

```{r}
sfix <- data.frame(summary(mod_rs_fe)$solutions[,1:5])
sfix$param <- row.names(sfix)
sfix$ds <- "study alone"
tfix <- data.frame(summary(modpt)$solutions[,1:5])
tfix$param <- row.names(tfix)
tfix$ds <- "study +\ntaxonomy"
pfix <- data.frame(summary(modp_rs_fe)$solutions[,1:5])
pfix$param <- row.names(pfix)
pfix$ds <- "study +\nphylogeny"
df_comp <- bind_rows(sfix, tfix, pfix)
df_comp <- mutate(df_comp,
                  ds = fct_relevel(ds, c("study alone", "study +\ntaxonomy", "study +\nphylogeny")),
                  param = factor(param, labels = c("host 1\n(intercept)",
                             "days post infection", "host mass", "worm size",
                             "host 1 vs 2", "host 1 vs 3"))
                  )%>%
  mutate(param = fct_relevel(param, c("host 1\n(intercept)", "host 1 vs 2", "host 1 vs 3",
                                      "days post infection", "host mass", "worm size")
                             )
         )

rm(sfix, tfix, pfix)
```
```{r}
s4 <- ggplot(data=df_comp) +
  geom_blank(aes(x = ds, y = post.mean)) +
  # geom_ribbon(aes(x = as.numeric(ds), ymin = l.95..CI, ymax = u.95..CI),
  #             alpha = 0.5, fill = "blue") +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_pointrange(aes(x = ds, y = post.mean, ymin = l.95..CI, ymax = u.95..CI, shape = ds),
                  color = "blue") +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank(),
        axis.text.x = element_blank()) +
  labs(x = "Model", y = "Parameter estimates", shape = NULL) +
  facet_wrap(~param, scales = "free")
s4
ggsave(s4, filename = "../../figs/figS4.png", width = 7, height = 5)
```

So, phylogeny does not have a clear effect on recovery, at least independent from study effects. Since phylogeny (1) does not affect the fixed effects, (2) is hard to estimate, and (3) intuitively should be low in this dataset, we leave it out of the main analysis.

# Model series for hypothesis testing

We now want to build a series of models. We'll use our random slopes model as the "base" model: it includes just study and days until dissection. We then add terms to this model to test explicit hypotheses. 

Here is the base model summary:

```{r}
summary(modp1_rsl)
```

Now let's get to hypothesis testing. Throughout we use the random slopes model with log-transformed time.

### Hypothesis 1: recovery rates are higher later in the life cycle

First, we test whether parasite life stage impacts establishment, specifically whether the parasite is infecting the first, second, third host, etc. To test this, we add 'step in cycle' to model.

```{r}
# starting conditions from lmer
rs <- (lme4::VarCorr(m2_rs0)["study_rs"][[1]])
attributes(rs) <- NULL
rs <- matrix(rs, 2)
startc <- list(R = as.numeric(lme4::VarCorr(m2_rs0)["obs"][[1]]),
               G = list(G1 = rs ),
               QUASI = FALSE)
rm(rs)

modp2 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
# reset start values for subsequent models
startc <- list(
  G = list(G1 = matrix(round(posterior.mode(modp2$VCV[,1:4]),4), 2) ),
  R = round(posterior.mode(modp2$VCV[,5]),4),
  QUASI = FALSE
  )
```

When we look at the parameter estimates, we see that recovery is significantly higher in second hosts than first hosts. The difference between second and third hosts is not significant.

```{r}
summary(modp2)
```

Model DIC is not much better with parasite stage, although the term was significant.

```{r}
cat("delta DIC, with and without 'next host':", round(modp1_rsl$DIC - modp2$DIC, 2), "(higher is better)")
```

The R^2^ table elucidates this contradiction. The overall model fit is not better. Instead, the fixed effect of stage now explains about 5% of the variation, which was subtracted from the "study" variation. In essence, different studies usually focus on different life stages, which in turn differ in their infection rates.

```{r}
m0 <- r2_univ_binom_rs(modp1_rsl)
m1 <- r2_univ_binom_rs(modp2)

m0$model <- "base random slopes, log time"
m1$model <- "parasite stage"

r2_table <- bind_rows(m0, m1)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1)
```

So life cycle step is important in determining infection rates. Let's plot the predicted means for different life stages at day one post infection (the intercept). Recovery rates increase with life cycle length, but the difference between 2nd and 3rd stage larva is not clear, since CIs overlap. For all stages, predicted recoveries are higher than observed ones. This is because most hosts were dissected after several days or even weeks.

```{r}
p <- predict(modp2, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(filter(datx, !is.na(log_ws), !is.na(log_hm)), p)
p <- select(p, log_dpi, nh_fac, fit, lwr, upr)%>%
  filter(log_dpi == log(1))%>%distinct()
p <- arrange(p, nh_fac)
```
```{r}
ggplot(datx,
       aes(y = Recovery_Rate, x = nh_fac, color = nh_fac)) +
  geom_boxplot(outlier.colour = NA) +
  geom_point(aes(size = n_hosts),
             alpha = 0.2, position = position_jitter(width = 0.3)) +
  guides(color = F) + 
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_size_continuous(trans = "log10") + 
  theme(panel.grid.major.x = element_blank()) +
  labs(x = "Host in cycle", 
       y = "Recovery Rate",
       size = "Number of\nhosts exposed") +
  geom_pointrange(data = p, aes(x = nh_fac, y = fit, ymin = lwr, ymax = upr),
                  color = 'black', size = 1.5)

```

When we plot the predictions at the median time of dissection (18 days), then predictions better match observed medians.

```{r}
p <- predict(modp2, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(filter(datx, !is.na(log_ws), !is.na(log_hm)), p)
p <- select(p, log_dpi, nh_fac, Recovery_Rate, fit, lwr, upr)%>%
  mutate(diff_from_wanted = abs(log_dpi - median(dat$log_dpi)))%>%
  arrange(diff_from_wanted)%>%
  group_by(nh_fac)%>%slice(1)
p <- arrange(p, nh_fac)
```
```{r}
ggplot(datx,
       aes(y = Recovery_Rate, x = nh_fac, color = nh_fac)) +
  geom_boxplot(outlier.colour = NA) +
  geom_point(aes(size = n_hosts),
             alpha = 0.2, position = position_jitter(width = 0.3)) +
  guides(color = F) + 
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_size_continuous(trans = "log10") + 
  theme(panel.grid.major.x = element_blank()) +
  labs(x = "Host in cycle", 
       y = "Recovery Rate",
       size = "Number of\nhosts exposed") +
  geom_pointrange(data = p, aes(x = nh_fac, y = fit, ymin = lwr, ymax = upr),
                  color = 'black', size = 1.5)
```

Here are those predicted means:

```{r}
select(p, nh_fac, fit, lwr, upr)
```

The differences among life stages were similar when estimated 1 or 18 dpi (though the CIs are obviously lower at the median of 18 dpi) because dissection times did not differ much among life stages.

```{r}
ggplot(datx,
       aes(y = exp(log_dpi), x = nh_fac, color = nh_fac)) +
  geom_boxplot(outlier.colour = NA) +
  geom_point(aes(size = n_hosts),
             alpha = 0.1, position = position_jitter(width = 0.3)) +
  guides(color = F)  +
  labs(x = "Next host in life cycle",
       y = "Time to dissection (days)", 
       size = "Number\nexposed") +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_size_continuous(trans = "log10") +
  scale_y_log10()
```

### Hypothesis 2: recovery rates differ in intermediate vs definitive hosts

The first host in a cycle can be an intermediate host (in a complex cycle) or a definitive host (in a direct cycle). Does this matter? To test this hypothesis, we distinguish between cases where worms infect intermediate vs definitive hosts. Before entering this term into a model, let's make sure that there are enough species and studies at each combination of life stage and host type. Here are the number of species in the different combinations. There are fewer intermediate host infections later in the life cycle, as expected.

```{r}
filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
  select(Species, nh_fac, to_int_def)%>%
  distinct()%>%
  with(., table(nh_fac, to_int_def))
```

Here are the number of studies:

```{r}
filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
  select(Study, nh_fac, to_int_def)%>%
  distinct()%>%
  with(., table(nh_fac, to_int_def))
```

Both tables suggest that there are several species and studies in each combination of life stage and int/def, so it is reasonable to add it to the mixed model.

```{r}
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm), !is.na(log_dpi))

mdpi <- median(dx$log_dpi, na.rm = T)

dxy <- bind_rows(
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate"),
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive"),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate"),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive"),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate"),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive")
)

dxy <- dxy%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = fct_relevel(st_id, c("1 Intermediate", "1 Definitive",
                                      "2 Intermediate", "2 Definitive",
                                      "3 Intermediate", "3 Definitive")))
dxy$pred <- 'yes'
dx <- bind_rows(dx, dxy)
rm(dxx, dxy, mdpi)
```
```{r}
modp2.00 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + to_int_def, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=F, 
                 verbose = F)
modp2.1 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac + to_int_def, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=F, 
                 verbose = F)
modp2.2 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=F, 
                 verbose = F)
# reset start values for subsequent models
startc <- list(
  G = list(G1 = matrix(round(posterior.mode(modp2.2$VCV[,1:4]),4), 2) ),
  R = round(posterior.mode(modp2.2$VCV[,5]),4),
  QUASI = FALSE
  )
```

The model suggests parasites have lower recovery rates in definitive hosts than in intermediate hosts.

```{r}
summary(modp2.1)
```

Model DIC is not much better though.

```{r}
cat("delta DIC, with int vs def:", round(modp2$DIC - modp2.1$DIC, 2), "(higher is better)")
```

Nor is it clear that recovery rates at a given life stage depend on whether the host is an intermediate or definitive host.

```{r}
cat("delta DIC, with stage x int/def interaction:", round(modp2$DIC - modp2.2$DIC, 2), "(higher is better)")
```

Here's how R^2^ changes. Like for parasite stage, the total variance explained does not increase much by adding the intermediate vs definitive host distinction, but more variation is attributed to the fixed effects.

```{r}
m0 <- r2_univ_binom_rs(modp2)
m1 <- r2_univ_binom_rs(modp2.1)
m2 <- r2_univ_binom_rs(modp2.2)

m0$model <- "base + parasite stage"
m1$model <- "+ to int vs def"
m2$model <- "+ stage by int vs def"

r2_table <- bind_rows(m0, m1, m2)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1, m2)
```

And here's the plot. Predicted means are at the median dissection time (18 dpi). Infections of first intermediate hosts are more successful than infection of first definitive hosts. But the opposite is true for second hosts.

```{r}
p <- predict(modp2.2, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
p <- filter(p, pred == 'yes')%>%
  arrange(st_id, log_ws)
```
```{r}
ggplot(datx,
       aes(y = Recovery_Rate, x = nh_fac, color = to_int_def)) +
  geom_boxplot(outlier.colour = NA) +
  geom_point(aes(size = n_hosts),
             alpha = 0.2, position = position_jitterdodge(jitter.width = 0.5)) +
  # guides(color = T) + 
  theme(panel.grid.major.x = element_blank()) +
  labs(x = "Next host in life cycle",
       y = "Recovery rate (Recovered/Dose)", 
       size = "Number\nexposed", color = "") +
  scale_size_continuous(trans = "log10") +
  geom_pointrange(data = p, 
                  aes(x = nh_fac, color = to_int_def, y = fit, ymin = lwr, ymax = upr),
                  size = 1.5,
                  position = position_dodge(width = 0.75))
```

The higher recovery in first or second intermediate hosts might be due to being dissected later, i.e. the model thinks the observed recovery rates are lower than they would be if they were dissected earlier.

```{r}
ggplot(datx,
       aes(y = exp(log_dpi), x = nh_fac, color = to_int_def)) +
  geom_boxplot(outlier.colour = NA) +
  geom_point(aes(size = n_hosts),
             alpha = 0.2, position = position_jitterdodge(jitter.width = 0.5)) +
  # guides(color = T) + 
  theme(panel.grid.major.x = element_blank()) +
  scale_y_log10() +
  labs(x = "Next host in life cycle",
       y = "DPI", 
       size = "Number\nexposed") +
  scale_size_continuous(trans = "log10") 
```
Here are the median dissection times.

```{r}
datx%>%
  group_by(nh_fac, to_int_def)%>%
  summarise(dpi = median(exp(log_dpi)))
```

But it likely is due to worms having larger infective stages when the next host is the definitive host.

```{r}
ggplot(datx,
       aes(y = exp(log_ws), x = nh_fac, color = to_int_def)) +
  geom_boxplot(outlier.colour = NA) +
  geom_point(aes(size = n_hosts),
             alpha = 0.2, position = position_jitterdodge(jitter.width = 0.5)) +
  # guides(color = T) + 
  theme(panel.grid.major.x = element_blank()) +
  scale_y_log10() +
  labs(x = "Next host in life cycle",
       y = "Worm size", 
       size = "Number\nexposed") +
  scale_size_continuous(trans = "log10") 
```

Thus, this term needs to be disentangled from our next model predictor, worm size. But before moving onto that, let's make a manuscript figure.

```{r}
# number of species in each group
p <- left_join(p,
               dx%>%
                 filter(is.na(pred))%>%
                 group_by(nh_fac, to_int_def)%>%
                 summarize(n_sp = n_distinct(Species)))
```
```{r}
f2 <- ggplot(filter(dx, is.na(pred)),
       aes(y = Recovery_Rate, x = nh_fac, shape = to_int_def)) +
  geom_boxplot(outlier.colour = NA) +
  geom_point(
    # aes(size = n_hosts),
    alpha = 0.2, size = 0.65,
    position = position_jitterdodge(jitter.width = 0.55)) +
  geom_pointrange(data = p,
                  aes(x = nh_fac, shape = to_int_def, y = fit, ymin = lwr, ymax = upr),
                  size = 1.5,
                  position = position_dodge(width = 0.75)) +
  geom_text(data = p, 
            aes(x = nh_fac, y = -0.03, label = n_sp, shape = to_int_def),
            size = 3,
            position = position_dodge(width = 0.75)) +
  scale_size_continuous(trans = "log10") +
  scale_x_discrete(labels = c("First", "Second", "Third")) +
  theme(panel.grid.major.x = element_blank(),
        legend.position = "bottom") +
  labs(x = "Host in cycle exposed", y = "Recovery rate",
       # size = "Number\nexposed",
       shape = "")
f2

ggsave(f2, filename = "../../figs/fig2.png", width = 4, height = 4)
ggsave(f2, filename = "../../figs/fig2.svg", width = 4, height = 4) # remove boxes under legend
```

### Hypothesis 3: recovery rates increase with worm size

Since later life stages targeting definitive hosts have better establishment rates, is this because they are larger? Let's add the size of infective parasite stages into the model. Moreover, if worm size drives the pattern, we expect the effect of "step" and the "int vs def" distinction to decrease once size is added. And there should not be an interaction between next host and parasite size.

```{r}
modp3.0 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + log_ws, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
modp3 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def + log_ws, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)

modp3.1 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac*to_int_def * log_ws, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
# reset start values for subsequent models
startc <- list(
  G = list(G1 = matrix(round(posterior.mode(modp3.1$VCV[,1:4]),4), 2) ),
  R = round(posterior.mode(modp3.1$VCV[,5]),4),
  QUASI = FALSE
  )
```

The worm size term is significant. Moreover, the difference among life stages decreased.

```{r}
summary(modp3)
```

Again, despite being significant, adding worm size is not a huge improvement, as judged by DIC.

```{r}
cat("delta DIC, after adding parasite size:", round(modp2.2$DIC - modp3$DIC, 2), "(higher is better)")
```

Neither is adding a worm size by stage interaction

```{r}
cat("delta DIC, after adding parasite size x stage:", round(modp3$DIC - modp3.1$DIC, 2), "(higher is better)")
```
Here is the summary from the more complex model with a worm size by stage interaction. Most of the interactions with worm size are not significant.

```{r}
summary(modp3.1)
```

Here's how R^2^ changes. The marginal R^2^ again increased at the expense of study-level variation, suggesting that some of the differences among studies is related to different sizes of infective stages. Adding the worm x stage interaction does not explain much variation either. Interestingly, worm size only explains 1-2% of the variation beyond that accounted for life stage, but by itself it explains 7% of the variation, nearly as much as life stage alone. Thus, worm size may explain the differences among stages.

```{r}
m0 <- r2_univ_binom_rs(modp2.2)
m1 <- r2_univ_binom_rs(modp3)
m2 <- r2_univ_binom_rs(modp3.1)
m3 <- r2_univ_binom_rs(modp3.0)

m0$model <- "base, stage, and int vs def"
m1$model <- "+ worm size"
m2$model <- "+ stage by worm size"
m3$model <- "base + worm size"

r2_table <- bind_rows(m0, m1, m2, m3)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1, m2, m3)
```
Now let's look at the worm size parameter, first without life stage in the model. Here is the posterior distribution for exp(worm size), i.e. the odds ratio. It suggests that a 1 unit increase in log worm size is associated with `r round(median(exp(modp3$Sol[,"log_ws"])), 2)` times better odds of infection. Note the odds are not the same as probability - the change in odds depends on the baseline infection probability. For example, if the baseline infection probability is 10%, then a 1 unit increase in log worm size increases infection probability `r 0.1 * round(median(exp(modp3$Sol[,"log_ws"])), 2) * 100`% (0.1 x odds ratio). But if the baseline is 50%, then the infection probability increases to `r 0.5 * round(median(exp(modp3$Sol[,"log_ws"])), 2) * 100`% (0.5 x odds ratio).

```{r}
summary(exp(modp3.0$Sol[,"log_ws"]))
```
Since worm size is log transformed, we need to interpret this coefficient with regards to proportional change. A change in 1 log unit corresponds to a exp(1) or 2.72-fold increase in worm size, so the odds ratio suggests the odds go up `r (round(median(exp(modp3$Sol[,"log_ws"])), 2)-1)*100`% with a 2.72-fold increase in worm size. We can express this with more intuitive percents. Here is the predicted percent increase in the odds of infection with a 10% increase in worm size.

```{r}
summary( exp(modp3.0$Sol[,"log_ws"] * log(1.1)) - 1) # beta x "log of fold change corresponding to 10% incr in size"
```
And for a 100% increase (2-fold increase):

```{r}
summary( exp(modp3.0$Sol[,"log_ws"] * log(2)) - 1) # beta x "log diff corresponding to doubling of size"
```
we can double check our calculation by refitting the model, but using log base 2 instead of ln. In this case the exp coefficient should correspond to the change in the odds with a doubling of worm size.

```{r}
lm_ws <- update(m2_rs0, . ~ . + log_ws2,
                data = filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
                  mutate(log_ws2 = log(exp(log_ws), base = 2)))
exp(fixef(lm_ws)["log_ws2"])-1
```

The odds ratio for worm size is a bit higher in the model including life stage.

```{r}
summary(exp(modp3$Sol[,"log_ws"]))
```

We want to plot predictions for different combinations of worm size and life stage. Let's make a new dataframe with the combinations of fixed effects at which we would like to predict recovery rate. Then we re-fit the model and extract the predictions and CI for plotting.

```{r}
# for MCMCglmm, need to add "missing" data, as new data for predictions
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm), !is.na(log_dpi))

mdpi <- median(dx$log_dpi, na.rm = T)

dxx <- group_by(datx, nh_fac, to_int_def)%>%
  summarize(min_ws = min(log_ws, na.rm = T),
            max_ws = max(log_ws, na.rm = T))
dxy <- bind_rows(
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_ws = seq(dxx$min_ws[1], dxx$max_ws[1], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_ws = seq(dxx$min_ws[2], dxx$max_ws[2], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_ws = seq(dxx$min_ws[3], dxx$max_ws[3], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_ws = seq(dxx$min_ws[4], dxx$max_ws[4], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_ws = seq(dxx$min_ws[5], dxx$max_ws[5], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_ws = seq(dxx$min_ws[6], dxx$max_ws[6], length.out = 50))
)

dxy <- dxy%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = fct_relevel(st_id, c("1 Intermediate", "1 Definitive",
                                      "2 Intermediate", "2 Definitive",
                                      "3 Intermediate", "3 Definitive")))
dxy$pred <- 'yes'
dx <- bind_rows(dx, dxy)
rm(dxx, dxy, mdpi)
```
```{r}
# refit model
modp3p <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def * log_ws, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=T, 
                 verbose = F)
```

We see that much of the variation across life stages can be explained by worm size. This suggests worm size is an important factor driving the increase in establishment with life cycle steps.

```{r}
# predicted values and SE
p <- predict(modp3p, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
p <- filter(p, pred == 'yes')%>%
  arrange(st_id, log_ws)
```
```{r}
f3 <- ggplot(dat,
       aes(y = Recovery_Rate, x = exp(log_ws), color = nh_fac, linetype = to_int_def )) +
  geom_point(aes(shape = to_int_def),
             position = position_jitter(width = 0.25),
             alpha = 0.3, size = 0.75) +
  geom_line(data = p, aes(x = exp(log_ws), y = fit), size = 1.5) +
  geom_ribbon(data = p, aes(ymin = lwr, ymax = upr, fill = nh_fac), alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) + 
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  scale_linetype_manual(values = c("dashed", "solid")) + 
  guides(color = F, 
         linetype = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1)),
         shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))) + 
  theme(panel.grid.minor = element_blank()) +
  labs(x = bquote("Worm Size "(~mm^3)),
       y = "Recovery Rate", 
       fill = "Host in cycle",
       shape = "", linetype = "") +
  theme(panel.grid.minor = element_blank()) 
  # facet_wrap(~to_int_def)
f3
# ggsave(f3, filename = "../../figs/fig3.png", width = 6, height = 4.5)
```

Plot is maybe better in separate panels, though the int vs def distinction is less clear...

```{r}
f3 <- ggplot(dat,
       aes(y = Recovery_Rate, x = exp(log_ws), color = nh_fac)) +
  geom_point(aes(),
             position = position_jitter(width = 0.25),
             alpha = 0.3, size = 0.75) +
  geom_line(data = p, aes(x = exp(log_ws), y = fit), size = 1.5) +
  geom_ribbon(data = p, aes(ymin = lwr, ymax = upr, fill = nh_fac), alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) + 
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  guides(color = F, 
         shape = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1))
         # shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))
         ) + 
  theme(panel.grid.minor = element_blank()) +
  labs(x = bquote("Worm size "(~mm^3)),
       y = "Recovery rate", 
       fill = "Host\nexposed",
       shape = "") +
  theme(panel.grid.minor = element_blank()) +
  facet_wrap(~to_int_def)
f3
# ggsave(f3, filename = "../../figs/fig3.png", width = 8, height = 4)
# ggsave(f3, filename = "../../figs/fig3.svg", width = 8, height = 4)
```

We can also make the same plot, but without the int vs def host distinction.

```{r}
# for MCMCglmm, need to add "missing" data, as new data for predictions
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm), !is.na(log_dpi))

mdpi <- median(dx$log_dpi, na.rm = T)

dxx <- group_by(datx, nh_fac)%>%
  summarize(min_ws = min(log_ws, na.rm = T),
            max_ws = max(log_ws, na.rm = T))
dxy <- bind_rows(
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1],
             log_ws = seq(dxx$min_ws[1], dxx$max_ws[1], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], 
             log_ws = seq(dxx$min_ws[2], dxx$max_ws[2], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1],
             log_ws = seq(dxx$min_ws[3], dxx$max_ws[3], length.out = 50))
)

dxy$pred <- 'yes'
dx <- bind_rows(dx, dxy)
rm(dxx, dxy, mdpi)
```
```{r}
# refit model
modp3p2 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * log_ws, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=T, 
                 verbose = F)
```
```{r}
# predicted values and SE
p <- predict.MCMCglmm(modp3p2, 
             type = 'terms',
             interval = 'confidence',
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
p <- filter(p, pred == 'yes')
```
```{r}
f3 <- ggplot(filter(dx, is.na(pred)),
       aes(y = Recovery_Rate, x = exp(log_ws), color = nh_fac )) +
  geom_point(
    # aes(size = (n_hosts)),
    position = position_jitter(width = 0.1),
    size = 0.75, alpha = 0.3) +
  geom_line(data = p, aes(x = exp(log_ws), y = fit), size = 1.5) +
  geom_ribbon(data = p, aes(ymin = lwr, ymax = upr, fill = nh_fac), alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) + 
  scale_color_brewer(palette = "Dark2", direction = -1, labels = c("First", "Second", "Third")) + 
  scale_fill_brewer(palette = "Dark2", direction = -1, labels = c("First", "Second", "Third")) + 
  scale_size_continuous(trans = "log10") + 
  guides(color = F, 
         linetype = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1)),
         shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))) + 
  theme(panel.grid.minor = element_blank()) +
  labs(x = bquote("Worm size "(~mm^3)),
       y = "Recovery rate", 
       fill = "Host in cycle",
       size = "Number of\nhosts exposed") +
  theme(panel.grid.minor = element_blank()) 
f3
ggsave(f3, filename = "../../figs/fig3.png", width = 6, height = 4)
ggsave(f3, filename = "../../figs/fig3.svg", width = 6, height = 4)
```
Here are the number of species in each group in the plot above. They differ slightly from those in figure 2, because a few species with facultative life cycles can infect different kinds of hosts at the same life stage (e.g. the first host for Toxocara can be an intermediate or definitive host).

```{r}
dx%>%
  filter(is.na(pred))%>%
  group_by(nh_fac)%>%
  summarize(n_sp = n_distinct(Species))%>%
  left_join(., dx%>%
              filter(is.na(pred))%>%
              group_by(nh_fac)%>%
              summarize(n_fams = n_distinct(parasite_family))
              )
```

It certainly looks like this pattern is consistent across the wide span of larval sizes. But some of the trend could be driven by detection bias. For example, small worms are harder to find and count. Thus, let's check if recovery still increases with worm size when we restrict the data to the largest third of worm stages.

```{r}
# worm sizes at stage level
sx <- datx%>%
  group_by(Species, nh_fac)%>%
  summarize(ws = mean(log_ws, na.rm = T))
q <- quantile(sx$ws, probs = 0.66, na.rm=T)

modp3.0l <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + log_ws, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm), log_ws > q),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
rm(q, sx)
```

After restricting the data to large worm stages that are unlikely to be overlooked, we still see a positive relationship between worm size and recovery in a model with just random slopes.

```{r}
summary(modp3.0l)
```


### Hypothesis 4: recovery rates depend on host mass

And what about hosts? Since hosts get larger as life cycles progress, this could drive the increase in recovery rates with "step". And might host mass actually explain recovery better than parasite size? Or do they interact, with comparably sized worms having a better chance at infecting a large or small host?

```{r}
modp4.0 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
modp4.01 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + log_hm*nh_fac*to_int_def, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
modp4 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def + log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```

When we added host mass to a model without parasite size, but with stage in the cycle, recovery rates decreased with host mass. This is not what we would expect if changes in host mass drove the pattern across life cycles (i.e. recovery rates were higher in latter stages where hosts were bigger), but rather suggests that host mass might explain variation within stages.

```{r}
summary(modp4)
```

Host mass alone explained about the same amount of variation as parasite size did, after accounting for stage. But when we consider host mass in the absence of stage data, it explains much less variance. This suggests recovery may vary with host mass within stages.

```{r}
m0 <- r2_univ_binom_rs(modp2.2)
m1 <- r2_univ_binom_rs(modp4)
m2 <- r2_univ_binom_rs(modp3)
m3 <- r2_univ_binom_rs(modp4.0)

m0$model <- "base, stage, and int vs def"
m1$model <- "+ host mass without worm size"
m2$model <- "+ worm size without host mass"
m3$model <- "base + host mass"

r2_table <- bind_rows(m0, m1, m2, m3)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1, m2, m3)
```

Here's how adding host mass impacts DIC.

```{r}
cat("delta DIC, after adding host mass to stage model:", round(modp2.2$DIC - modp4$DIC, 2), "(higher is better)")
```

Let's look at the host mass parameter, first without life stage in the model and then with it. Here is the posterior distribution for the odds ratio without stage.

```{r}
summary(exp(modp4.0$Sol[,"log_hm"]))
orx <- 1-median(exp(modp4.0$Sol[,"log_hm"]))
```

It suggests the odds decrease `r round(orx,2)*100`% for a 1 unit change in host mass. Here is the predicted percent decrease in the odds of infection with a 10% increase in host mass...

```{r}
summary( 1 - exp(modp4.0$Sol[,"log_hm"] * log(1.1)) ) # beta x "log of fold change corresponding to 10% incr in size"
```
...and for a doubling of host mass.

```{r}
summary( 1 - exp(modp4.0$Sol[,"log_hm"] * log(2)) ) # beta x "log of fold change corresponding to 100% incr in size"
```
Surprisingly, the odds ratio for host mass get closer to 1 (smaller effect) when we control for life stage.

```{r}
summary(exp(modp4$Sol[,"log_hm"]))
```

But is the effect of host mass independent of parasite size? And is it consistent across stages? Let's add host mass to models already including parasite size and check its interaction with stage.

```{r}
modp4.1 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def * log_ws + log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
modp4.2 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def * log_ws + 
                      nh_fac * to_int_def * log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
# reset start values for subsequent models
startc <- list(
  G = list(G1 = matrix(round(posterior.mode(modp4.2$VCV[,1:4]),4), 2) ),
  R = round(posterior.mode(modp4.2$VCV[,5]),4),
  QUASI = FALSE
  )
```

Adding a host mass main effect to a model with a worm size x stage interaction is not much of an improvement.

```{r}
cat("delta DIC, after adding host mass to model with worm size:", round(modp3.1$DIC - modp4.1$DIC, 2), "(higher is better)")
```

But there might be an interaction between host mass and life stage.

```{r}
cat("delta DIC, after adding host mass x stage interaction:", round(modp4.1$DIC - modp4.2$DIC, 2), "(higher is better)")
```

The R^2^ table suggests that allowing host mass to interact with stage explains a few percentage points of the variation, and this does not clearly come at the expense of worm size since overall fit increased.

```{r}
m0 <- r2_univ_binom_rs(modp3.1)
m1 <- r2_univ_binom_rs(modp4.1)
m2 <- r2_univ_binom_rs(modp4.2)

m0$model <- "base, stage x worm size"
m1$model <- "+ host mass"
m2$model <- "+ host mass x stage interaction"

r2_table <- bind_rows(m0, m1, m2)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1, m2)
```

The step x host mass interaction terms were generally not significant but they did vary in sign.

```{r}
summary(modp4.2)
```

Let's plot these host mass effects.

```{r}
# for MCMCglmm, need to add "missing" data, as new data for predictions
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm), !is.na(log_dpi))

mdpi <- median(dx$log_dpi, na.rm = T)

dxx <- group_by(datx, nh_fac, to_int_def)%>%
  summarize(min_hm = min(log_hm, na.rm = T),
            max_hm = max(log_hm, na.rm = T),
            mean_ws = mean(unique(log_ws), na.rm = T))
dxy <- bind_rows(
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[1], dxx$max_hm[1], length.out = 50),
             log_ws = dxx$mean_ws[1]),
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[2], dxx$max_hm[2], length.out = 50),
             log_ws = dxx$mean_ws[2]),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[3], dxx$max_hm[3], length.out = 50),
             log_ws = dxx$mean_ws[3]),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[4], dxx$max_hm[4], length.out = 50),
             log_ws = dxx$mean_ws[4]),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[5], dxx$max_hm[5], length.out = 50),
             log_ws = dxx$mean_ws[5]),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[6], dxx$max_hm[6], length.out = 50),
             log_ws = dxx$mean_ws[6])
)
dxy <- dxy%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = fct_relevel(st_id, c("1 Intermediate", "1 Definitive",
                                      "2 Intermediate", "2 Definitive",
                                      "3 Intermediate", "3 Definitive")))
dxy$pred <- 'yes'
dx <- bind_rows(dx, dxy)
rm(dxx, dxy, mdpi)
```
```{r}
# refit model
modp4.1p <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def * log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```
```{r}
# predicted values and SE
p <- predict(modp4.1p, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
p <- filter(p, pred == 'yes')%>%
  arrange(nh_fac, log_hm)
```

These are the model predictions without accounting for worm size (i.e. just host mass in the model). There are not clear, consistent trends.

```{r}
ggplot(datx,
       aes(y = Recovery_Rate, x = exp(log_hm), color = nh_fac, linetype = to_int_def )) +
  geom_point(aes(shape = to_int_def),
             position = position_jitter(width = 0.25),
             alpha = 0.3) +
  geom_line(data = p, aes(x = exp(log_hm), y = fit), size = 2) +
  geom_ribbon(data = p, aes(ymin = lwr, ymax = upr, fill = nh_fac), alpha = 0.3, color = NA) +
  scale_x_log10() + 
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  guides(color = F, fill = F) + 
  theme(panel.grid.major.x = element_blank()) +
  labs(x = "Host mass (g)", y = "Recovery rate (Recovered/Dose)", 
       size = "Log number\nanimals exposed",
       linetype = "Intermediate vs\nDefinitive Host",
       shape = "Intermediate vs\nDefinitive Host") +
  theme(panel.grid.minor = element_blank()) 
  # facet_wrap(~to_int_def)
```

Let's look at the same plot, but while controlling for worm size - the predicted values in the next plot are for the average worm size in each stage. It does not differ much from the previous plot.

```{r}
# refit model
modp4.2p <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def * log_ws + 
                       nh_fac * to_int_def * log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```
```{r}
# predicted values and SE
p <- predict(modp4.2p, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
p <- filter(p, pred == 'yes')%>%
  arrange(nh_fac, log_hm)
```
```{r}
f4 <- ggplot(datx,
       aes(y = Recovery_Rate, x = exp(log_hm), color = nh_fac, linetype = to_int_def )) +
  geom_point(aes(shape = to_int_def),
             position = position_jitter(width = 0.25),
             alpha = 0.3, size = 0.75) +
  geom_line(data = p, aes(x = exp(log_hm), y = fit), size = 1.5) +
  geom_ribbon(data = p, aes(ymin = lwr, ymax = upr, fill = nh_fac), alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) + 
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  scale_linetype_manual(values = c("dashed", "solid")) + 
  guides(color = F, 
         linetype = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1)),
         shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))) + 
  theme(panel.grid.minor = element_blank()) +
  labs(x = "Host mass (g)",
       y = "Recovery rate", 
       fill = "Host\nexposed",
       shape = "", linetype = "") +
  theme(panel.grid.minor = element_blank()) 
  # facet_wrap(~to_int_def)
f4
# ggsave(f4, filename = "../../figs/fig4.png", width = 6, height = 4.5)
```

Better in two panels?

```{r}
f4 <- ggplot(datx,
       aes(y = Recovery_Rate, x = exp(log_hm), color = nh_fac)) +
  geom_point(aes(),
             position = position_jitter(width = 0.25),
             alpha = 0.3, size = 0.75) +
  geom_line(data = p, aes(x = exp(log_hm), y = fit), size = 1.5) +
  geom_ribbon(data = p, aes(ymin = lwr, ymax = upr, fill = nh_fac), alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) + 
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  # scale_linetype_manual(values = c("dashed", "solid")) + 
  guides(color = F, 
         linetype = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1))
         # shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))
         ) + 
  theme(panel.grid.minor = element_blank()) +
  labs(x = "Host mass (g)",
       y = "Recovery rate", 
       fill = "Host\nexposed",
       shape = "", linetype = "") +
  theme(panel.grid.minor = element_blank()) +
  facet_wrap(~to_int_def)
f4
# ggsave(f4, filename = "../../figs/fig4.png", width = 8, height = 4)
# ggsave(f4, filename = "../../figs/fig4.svg", width = 8, height = 4)
```

We can make the same plot, but just distinguishing host in cycle, not int vs def.

```{r}
# for MCMCglmm, need to add "missing" data, as new data for predictions
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm), !is.na(log_dpi))

mdpi <- median(dx$log_dpi, na.rm = T)

dxx <- group_by(datx, nh_fac)%>%
  summarize(min_hm = min(log_hm, na.rm = T),
            max_hm = max(log_hm, na.rm = T),
            mean_ws = mean(unique(log_ws), na.rm = T))
dxy <- bind_rows(
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1],
             log_hm = seq(dxx$min_hm[1], dxx$max_hm[1], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], 
             log_hm = seq(dxx$min_hm[2], dxx$max_hm[2], length.out = 50)),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1],
             log_hm = seq(dxx$min_hm[3], dxx$max_hm[3], length.out = 50))
)
dxy$pred <- 'yes'
dx <- bind_rows(dx, dxy)
rm(dxx, dxy, mdpi)
```
```{r}
# refit model
modp4.1p2 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=F, 
                 verbose = F)

# predicted values and SE
p <- predict(modp4.1p2, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
p <- filter(p, pred == 'yes')%>%
  arrange(nh_fac, log_hm)
```
```{r}
f4 <- ggplot(filter(dx, is.na(pred)),
       aes(y = Recovery_Rate, x = exp(log_hm), color = nh_fac )) +
  geom_point(
    # aes(size = n_hosts),
    position = position_jitter(width = 0.1),
    size = 0.75, alpha = 0.3) +
  geom_line(data = p, aes(x = exp(log_hm), y = fit), size = 1.5) +
  geom_ribbon(data = p, aes(ymin = lwr, ymax = upr, fill = nh_fac), alpha = 0.2, color = NA) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) + 
  scale_color_brewer(palette = "Dark2", direction = -1, labels = c("First", "Second", "Third")) + 
  scale_fill_brewer(palette = "Dark2", direction = -1, labels = c("First", "Second", "Third")) + 
  scale_size_continuous(trans = "log10") + 
  guides(color = F, 
         linetype = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1))
         ) + 
  theme(panel.grid.minor = element_blank()) +
  labs(x = "Host mass (g)",
       y = "Recovery rate", 
       fill = "Host in cycle",
       size = "Number of\nhosts exposed") +
  theme(panel.grid.minor = element_blank()) 
f4
ggsave(f4, filename = "../../figs/fig4.png", width = 6, height = 4)
ggsave(f4, filename = "../../figs/fig4.svg", width = 6, height = 4)
```
It looks like the slope is most negative for first hosts and then increases with life cycle progression. Let's check the parameter estimates. Here is the estimated "first host" slope:

```{r}
summary(modp4.1p2$Sol[,"log_hm"])
```
"Second host" slope:

```{r}
summary(modp4.1p2$Sol[,"log_hm"] + modp4.1p2$Sol[,"nh_fac2:log_hm"])
```
And "third host" slope:

```{r}
summary(modp4.1p2$Sol[,"log_hm"] + modp4.1p2$Sol[,"nh_fac3:log_hm"])
```

The first host slope is significantly negative, but the second and third host slopes are not significantly different from zero (or the first host slope).

Finally, we can check whether worm size and host size interact. In other words, is being big relatively more important when the next host is big (or small)?

```{r}
modp4.3 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def + log_ws * log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
modp4.4 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + nh_fac * to_int_def * log_ws + 
                      nh_fac * to_int_def * log_hm +
                      log_ws * log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```

Let's first check without stage x covariate interactions. That is, we'll add the worm size by host mass interaction to a model with just stage. The interaction term is not significant.

```{r}
summary(modp4.3)
```

And the R^2^ value does not increase much with this interaction.

```{r}
m0 <- r2_univ_binom_rs(modp2.2)
m1 <- r2_univ_binom_rs(modp4)
m2 <- r2_univ_binom_rs(modp3)
m3 <- r2_univ_binom_rs(modp4.3)

m0$model <- "base, stage, and int vs def"
m1$model <- "+ host mass (alone, no worm size)"
m2$model <- "+ worm size (alone, no host mass)"
m3$model <- "+ worm size x host mass interaction"

r2_table <- bind_rows(m0, m1, m2, m3)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1, m2, m3)
```

Likewise, the host mass by worm size interaction was not significant when added to a model with stage interactions. This is not surprising, given that we already allow worm and host size effects to vary across the steps of the life cycle.

```{r}
summary(modp4.4)
```

And it explained essentially no additional variation in recovery rates.

```{r}
m0 <- r2_univ_binom_rs(modp4.2)
m1 <- r2_univ_binom_rs(modp4.4)

m0$model <- "base, worm size x stage, host mass x stage"
m1$model <- "+ worm size x host mass interaction"

r2_table <- bind_rows(m0, m1)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1)
```

The model is worse, judged by DIC.

```{r}
cat("delta DIC, after adding host mass x worm size interaction to model with worm size and host mass:", round(modp4.2$DIC - modp4.4$DIC, 2), "(higher is better)")
```

We can also compare the worm and host size parameters in a model with just those two terms.

```{r}
modp4.5 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi + log_ws + log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```

Worm size has twice as large an effect. 

```{r}
summary(modp4.5)
```

In sum, establishment decreases with host mass, though this varies with life stage.

## Hypothesis 5: recover rate over time depends on step in the cycle

Are worms lost faster from the second host than the first host? To test this, let's examine the interaction between time to dissection and step. I'll add this interaction to a model without host mass and worm size and then to a model with those two variables.

```{r}
modp5 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi * nh_fac * to_int_def + nh_fac * to_int_def, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=F, 
                 verbose = F)

modp5.1 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi * nh_fac * to_int_def +
                      nh_fac * to_int_def * log_ws + 
                    nh_fac * to_int_def * log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = filter(datx, !is.na(log_ws), !is.na(log_hm)),
                 family = 'multinomial2', pr=T, 
                 verbose = F)
```

Here is how a time x stage interaction impacts DIC. 

```{r}
cat("delta DIC, added dpi x step interaction to model with just their main effects:", round(modp2.2$DIC - modp5$DIC, 2), "(higher is better)")
```

But the effect is small, as judged by R^2^

```{r}
m0 <- r2_univ_binom_rs(modp2.2)
m1 <- r2_univ_binom_rs(modp5)

m0$model <- "base, stage"
m1$model <- "+ time dpi x stage interaction"

r2_table <- bind_rows(m0, m1)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1)
```

Here is the change in model DIC when this time x stage interaction is added to a model with host and parasite size effects.

```{r}
cat("delta DIC, added dpi x step interaction to model with just their main effects:", round(modp4.2$DIC - modp5.1$DIC, 2), "(higher is better)")
```

```{r}
m0 <- r2_univ_binom_rs(modp4.2)
m1 <- r2_univ_binom_rs(modp5.1)

m0$model <- "with worm and host size, and their interactions"
m1$model <- "+ time dpi x stage interaction"

r2_table <- bind_rows(m0, m1)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1)
```

And the terms of this time by stage interaction are not significant.

```{r}
summary(modp5.1)
```

Let's plot the relationship between time and recovery predicted by the model. 

```{r}
# for MCMCglmm, need to add "missing" data, as new data for predictions
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm), !is.na(log_dpi))

dxx <- group_by(datx, nh_fac, to_int_def)%>%
  summarize(min_dpi = min(log_dpi, na.rm = T),
            max_dpi = max(log_dpi, na.rm = T),
            mean_ws = mean(log_ws, na.rm = T),
            mean_hs = mean(log_hm, na.rm = T))
dxy <- bind_rows(
  data.frame(nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_dpi = seq(dxx$min_dpi[1], dxx$max_dpi[1], length.out = 50),
             log_ws = dxx$mean_ws[1], log_hm = dxx$mean_hs[1]),
  data.frame(nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_dpi = seq(dxx$min_dpi[2], dxx$max_dpi[2], length.out = 50),
             log_ws = dxx$mean_ws[2], log_hm = dxx$mean_hs[2]),
  data.frame(nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_dpi = seq(dxx$min_dpi[3], dxx$max_dpi[3], length.out = 50),
             log_ws = dxx$mean_ws[3], log_hm = dxx$mean_hs[3]),
  data.frame(nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_dpi = seq(dxx$min_dpi[4], dxx$max_dpi[4], length.out = 50),
             log_ws = dxx$mean_ws[4], log_hm = dxx$mean_hs[4]),
  data.frame(nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_dpi = seq(dxx$min_dpi[5], dxx$max_dpi[5], length.out = 50),
             log_ws = dxx$mean_ws[5], log_hm = dxx$mean_hs[5]),
  data.frame(nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_dpi = seq(dxx$min_dpi[6], dxx$max_dpi[6], length.out = 50),
             log_ws = dxx$mean_ws[6], log_hm = dxx$mean_hs[6])
)
dxy <- dxy%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = fct_relevel(st_id, c("1 Intermediate", "1 Definitive",
                                      "2 Intermediate", "2 Definitive",
                                      "3 Intermediate", "3 Definitive")))
dxy$pred <- 'yes'
dx <- bind_rows(dx, dxy)
rm(dxx, dxy, mdpi)
```
```{r}
# refit model
modp5.1p <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi * nh_fac * to_int_def +
                      nh_fac * to_int_def * log_ws + 
                    nh_fac * to_int_def * log_hm, 
                 random = ~ us(1+log_dpi):study_rs,
                 prior = priorRS,
                 start = startc,
                 nitt = nit, thin = 20, burnin = bi,
                 data = dx,
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```
```{r}
# predicted values and SE
p <- predict(modp5.1p, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~ us(1+log_dpi):study_rs
             )
p <- boot::inv.logit(p) # convert to proportions
p <- cbind(dx, p)
p <- filter(p, pred == 'yes')%>%
  arrange(nh_fac)
```

There are not consistent changes in recovery over time across stages. The predicted relationships are very uncertain (large CIs), which makes sense, since different studies yielded different recovery x time relationships (i.e. the random slopes).

```{r}
ggplot(dat,
       aes(y = Recovery_Rate, x = Time_Dissection, color = nh_fac )) +
  geom_point(aes(shape = to_int_def),
             position = position_jitter(width = 0.25),
             alpha = 0.3) +
  geom_line(data = p, aes(x = exp(log_dpi), y = fit), size = 2) +
  geom_ribbon(data = p, aes(x = exp(log_dpi), ymin = lwr, ymax = upr, fill = nh_fac), alpha = 0.3, color = NA) +
  scale_x_log10() +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  # scale_linetype_manual(values = c("dashed", "solid")) + 
  guides(color = F, 
         linetype = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1)),
         shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))) + 
  theme(panel.grid.minor = element_blank()) +
  labs(x = "Time to dissection (days)", y = "Recovery rate (Recovered/Dose)", 
       fill = "Host in cycle",
       linetype = "",
       shape = "") +
  theme(panel.grid.minor = element_blank()) + 
  facet_wrap(~to_int_def)
```
### Double check phylogeny again

Finally, let's check phylogeny again, now that we have a model full of predictors.

```{r}
priorP <- list(R=list(V=1, nu=0.002), 
               G = list(G1 = list(V = diag(2), nu = 2),
                        G2 = list(V=1, nu = 1, alpha.mu = 0, alpha.V = 1000))) # parameter expanded prior for phylo effect
```
```{r}
modp5.2 <- MCMCglmm(cbind(succeeded, failed) ~ log_dpi * nh_fac * to_int_def +
                      nh_fac * to_int_def * log_ws + 
                    nh_fac * to_int_def * log_hm, 
                 random = ~ us(1+log_dpi):study_rs + tree_tips,
                 prior = priorP,
                 nitt = nit, thin = 20, burnin = bi,
                 data = as.data.frame(filter(datx, !is.na(log_ws), !is.na(log_hm))),
                 ginverse=list(tree_tips=Ainv),
                 family = 'multinomial2', pr=F, 
                 verbose = F)
```

Adding phylogeny to the model is not an improvement by DIC...

```{r}
cat("delta DIC, saturated model with and without phylogeny:", round(modp5.1$DIC - modp5.2$DIC, 2), "(higher is better)")
```

...or by R^2^.

```{r}
m0 <- r2_univ_binom_rs(modp5.1)
m1 <- r2_univ_binom_rs(modp5.2)

m0$model <- "with worm and host size, and their interactions"
m1$model <- "+ time dpi x stage interaction"

r2_table <- bind_rows(m0, m1)%>%
  select(model, r2m, r2c)
r2_table
rm(m0, m1)
```

The lower bound is also near zero when we look at the trace.

```{r}
plot(modp5.2$VCV[,"tree_tips"])
```

Thus, phylogeny does not seem important.

# Conclusions

We examined the determinants of establishment rate in worms. It can vary a lot from one study to the next as well as within studies due to e.g. dose or time differences (Fig. 1). Establishment rate tends to increase with life cycle progression, especially when the next host is the definitive host (Fig. 2). This effect is partly driven by worm size, with larger worms having higher establishment rates (Fig. 3). Establishment decreases in big hosts, but the effect is variable across the life cycle (Fig. 4).

```{r}
# the series of models fit
mod_series <- c("base (time post infection & study random effect)",
                "+ time dpi x study (random slopes)",
                "+ next host in cycle",
                "+ intermediate or definitive host",
                "+ next host x int vs def",
                "+ worm size",
                "+ worm size x stage",
                "+ host mass",
                "+ host mass x stage",
                "+ time dpi x stage"
                )
```
```{r}
m0 <- r2_univ_binom(modp1lp) 
m1 <- r2_univ_binom_rs(modp1_rsl)
m2 <- r2_univ_binom_rs(modp2)
m3 <- r2_univ_binom_rs(modp2.1)
m4 <- r2_univ_binom_rs(modp2.2)
m5 <- r2_univ_binom_rs(modp3)
m6 <- r2_univ_binom_rs(modp3.1)
m7 <- r2_univ_binom_rs(modp4.1)
m8 <- r2_univ_binom_rs(modp4.2)
m9 <- r2_univ_binom_rs(modp5.1)

r2_table <- bind_rows(m0, m1, m2, m3, m4, m5, m6, m7, m8, m9)
r2_table$model <- mod_series
r2_table <- r2_table%>%select(model, r2m, r2c)
rm(m0, m1, m2, m3, m4, m5, m6, m7, m8, m9)
```

We can quantitatively summarize the results by making an R^2^ table. The table suggests that recovery rates from the same study are quite similar, especially if we account for time-dependence within studies (i.e the random-slopes model accounted for about 10% additional variation). However, the variance explained solely by study (conditional - marginal R^2^) tends to go down as we add predictors, indicating that differences from one study to the next can be partly explained by things like life stage and worm size. Among the predictors, life stage, worm size, and host mass all had clear effects.

```{r}
r2_table
```

To double check my R^2^ calculations, I refit all the models in the table above with `glmer` and then calculated R^2^. This is simpler because, unlike with `MCMCglmm` I am not putting CIs on the variance components. With `glmer` models it is also simple to perform likelihood ratio tests and have p-values for model comparisons.

```{r}
# lm0 <- glmer(cbind(succeeded, failed)~ log_dpi + (1|study_rs) + (1|obs),
#             data = filter(dat, !is.na(log_ws), !is.na(log_hm))),
#             family = 'binomial')
# lm1 <- update(lm0, . ~ . + (log_dpi|study_rs) - (1|study_rs))
lm0 <- m2_r0l
lm1 <- m2_rs0
lm2 <- update(lm1, . ~ . + nh_fac)
lm3 <- update(lm2, . ~ . + to_int_def)
lm4 <- update(lm3, . ~ . + nh_fac*to_int_def)
lm5 <- update(lm4, . ~ . + log_ws)
lm6 <- update(lm5, . ~ . + nh_fac*to_int_def*log_ws)
lm7 <- update(lm6, . ~ . + log_hm)
lm8 <- update(lm7, . ~ . + nh_fac*to_int_def*log_hm)
lm9 <- update(lm8, . ~ . + nh_fac*to_int_def*log_dpi)
lrt <- anova(lm0, lm1, lm2, lm3, lm4, lm5, lm6, lm7, lm8, lm9)
```

The R^2^ values from `glmer` models look very comparable for marginal R^2^, but conditional R^2^ tends to be a bit lower (6% lower in the most complex model). The main reason seems to be that the random effects VC tends to be slightly high in `MCMCglmm`. I've observed this in previous studies too and I cannot say why exactly `MCMCglmm` yields slightly higher VCs. I played with priors, but unless the priors are very strong, this has very little impact on the posterior parameter estimates. But overall, the similarity is reassuring.

```{r}
# lapply(mod_list, MuMIn::r.squaredGLMM) # returns too high R2, because obs-level RE not considered error
```
```{r}
mod_list <- list(lm0, lm1, lm2, lm3, lm4, lm5, lm6, lm7, lm8, lm9)
if(exists("r2_table")){rm(r2_table)}
i <- 1
for(model in mod_list){
  if(i == 1){
    r2_table <- r2_glmm_tax(model)
  } else {
    r2_table <- rbind(r2_table, r2_glmm_tax(model))
  }
  i <- i + 1
}

r2_table <- mutate(r2_table, study_var_explained = cond_r2 - marg_r2, df_used = df - lag(df))
r2_table$step <- mod_series
r2_table$LRT_pval <- round(lrt$`Pr(>Chisq)`, 5)
r2_table <- dplyr::select(r2_table, step, df_used, LRT_pval,
                          # VF, VR, VD, VE, 
                          marg_r2, cond_r2, study_var_explained)
r2_table
```

The likelihood ratio tests are also included in the table, and they suggest that the model improves by adding random slopes, adding life stage (both next host and the int vs def distinction), adding worm size, and adding host mass, but not the size x stage interactions.

Let's also check these terms individually. How much variation do they explain on their own? Marginal R^2^ represents the variance explained by each term alone. They tend to be consistently positive, implying each term alone can explain some variance in recovery. The combinations of worm size and stage and host size and stage explain the most variation, so the effects of size and stage are not entirely redundant.

```{r}
# the series of models fit
mod_series <- c("+ next host in cycle",
                "+ intermediate or definitive host",
                "+ next host x int vs def",
                "+ worm size",
                "+ worm size x stage",
                "+ host mass",
                "+ host mass x stage"
                )
```
```{r}
m0 <- r2_univ_binom_rs(modp2)
m1 <- r2_univ_binom_rs(modp2.00)
m2 <- r2_univ_binom_rs(modp2.2)
m3 <- r2_univ_binom_rs(modp3.0)
m4 <- r2_univ_binom_rs(modp3.1)
m5 <- r2_univ_binom_rs(modp4.0)
m6 <- r2_univ_binom_rs(modp4.01)

r2_table <- bind_rows(m0, m1, m2, m3, m4, m5, m6)
r2_table$model <- mod_series
r2_table <- r2_table%>%select(model, r2m, r2c)
rm(m0, m1, m2, m3, m4, m5, m6)
```
```{r}
r2_table
```

In addition to looking at how "explanatory" terms are alone, we can also gauge how important they are in the full, final model. Here are the significant parameters in the final model: stage, host mass, and worm size by stage.

```{r}
s <- data.frame(quant = summary(modp4.2$Sol)$quantiles)
mutate(s, param = row.names(s))%>%
  mutate(sig = if_else( !(`quant.2.5.` < 0 & `quant.97.5.` > 0), "sig", "ns"))%>%
  select(param, lwr = `quant.2.5.`, fit = `quant.50.`, upr = `quant.97.5.`, sig)%>%
  filter(sig == "sig")
```


As we now know what kinds of experiments yield high recovery rates (late stage in life cycle, large larvae, small host for given stage), let's look at whether doses follow these trends. That is, do researchers use higher doses when they expect lower recoveries?

# Dose as response variable

Here is the distribution of doses - it varies a lot - but it is reasonably normal on a log scale.

```{r}
qplot(dat$Dose) + scale_x_log10()
```

Thus, let's fit the same series of models as for recovery rate, but with dose as response variable. We can probably also drop the time of dissection from the model too - it is not obvious why one should use higher doses when dissection dates are earlier/later. Let's check whether dose and dissection time covary. There is a slight tendency to use higher doses when dissecting later.

```{r}
ggplot(select(dat, Study, Time_Dissection, nh_fac, Dose, to_int_def)%>%
         distinct(),
       aes(x = Time_Dissection, y = Dose, color = nh_fac)) +
  geom_point(alpha = 0.2) +
  geom_smooth(se = F, method = lm) +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_y_log10() + scale_x_log10() +
  facet_wrap(~to_int_def)
```

And here is a likelihood ratio test - adding dissection time weakly predicts dose.

```{r}
lmd0 <- lmer(log_dose ~ nh_fac*to_int_def + (1|study_rs),
            data = filter(datx, !is.na(log_ws), !is.na(log_hm))
            )
lmd00 <- lmer(log_dose ~ nh_fac*to_int_def + log_dpi + (1|study_rs),
            data = filter(datx, !is.na(log_ws), !is.na(log_hm))
            )
lmd000 <- lmer(log_dose ~ nh_fac*to_int_def + log_dpi + (1+log_dpi|study_rs),
            data = filter(datx, !is.na(log_ws), !is.na(log_hm))
            )
anova(lmd0, lmd00)
```
within studies, are higher doses used with later dissection points? Here are most of the studies with multiple doses and dissection times. Usually the dose does not vary much with the time of dissection, suggesting the same random slopes structure is not needed for 'dose' models.

```{r}
st <- filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
  group_by(Study)%>%
  summarise(ndose = n_distinct(log_dose),
            ndpi = n_distinct(log_dpi))%>%
  filter(ndose > 1, ndpi > 1)%>%
  arrange(desc(ndose))%>%
  ungroup()%>%
  slice(1:49)%>%
  .$Study

ggplot(filter(datx, Study %in% st)%>%
         mutate(Study = factor(Study, levels=st)),
       aes(x = exp(log_dpi), y = log_dose, color = nh_fac)) +
  geom_point(aes(size = log(n_hosts)), alpha = 0.4) +
  geom_smooth(aes(group = study_rs), method = lm, se = F) +
  geom_smooth(aes(group = study_rs), method = lm, formula = y ~ log(x), se = F, linetype = 'dashed') +
  labs(x = "Time dpi", y = "Dose", 
       title = "Dose over time within studies", 
       color = "Next Host", size = "Log num hosts") +
  facet_wrap(~Study, scales = 'free_x') +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  theme(axis.text.x = element_blank(),
        strip.text = element_blank(),
        panel.grid.minor = element_blank())
```

So let's model log dose using standard linear mixed models (not random slopes). As for recovery rates, we add life stage, worm size, and host mass.

```{r}
# lmer - fit saturated one with MCMCglmm to estimate CIs for fig
lmd0 <- lmer(log_dose ~ 1 + (1|study_rs),
            data = filter(datx, !is.na(log_ws), !is.na(log_hm))
            )
lmd1 <- update(lmd0, . ~ . + nh_fac)
lmd2 <- update(lmd1, . ~ . + to_int_def)
lmd3 <- update(lmd2, . ~ . + nh_fac*to_int_def)
lmd4 <- update(lmd3, . ~ . + log_ws)
lmd5 <- update(lmd4, . ~ . + nh_fac*to_int_def*log_ws)
lmd6 <- update(lmd5, . ~ . + log_hm)
lmd7 <- update(lmd6, . ~ . + nh_fac*to_int_def*log_hm)
lrt <- anova(lmd0, lmd1, lmd2, lmd3, lmd4, lmd5, lmd6, lmd7)
```
```{r}
r2_lmm <- function(model) {

  # model stuff
  call <- as.character(model@call)[2]
  X <- model.matrix(model)
  n <- nrow(X)
  Beta <- fixef(model)
  df <- length(Beta) - 1
  
  # variance due to fixed effects
  Sf <- var(X %*% Beta)
  
  # variance due to rand effects
  Sigma.list <- VarCorr(model)
  Sl <- 
    sum(
      sapply(Sigma.list["study_rs"], # not obs-level RE
        function(Sigma)
        {
          Z <-X[,rownames(Sigma)]
          sum(diag(Z %*% Sigma %*% t(Z)))/n
        }))
  
  Se <- attr(Sigma.list, "sc")^2 # error

  total.var <- c(Sf + Sl + Se)
  mr2 <- c(Sf / total.var)
  cr2 <- c((Sf + Sl) / total.var)

  # output
  out_frame <- data_frame(call = call, df = df, 
                          VF = as.numeric(Sf), VR = as.numeric(Sl), VE = as.numeric(Se),
                          marg_r2 = round(mr2, 3), cond_r2 = round(cr2,3))
  return(out_frame)
}
```
```{r}
mod_list <- list(lmd0, lmd1, lmd2, lmd3, lmd4, lmd5, lmd6, lmd7)
# lapply(mod_list, MuMIn::r.squaredGLMM) # returns ok r2

if(exists("r2_table")){rm(r2_table)}
i <- 1
for(model in mod_list){
  if(i == 1){
    r2_table <- r2_lmm(model)
  } else {
    r2_table <- rbind(r2_table, r2_lmm(model))
  }
  i <- i + 1
}

r2_table <- mutate(r2_table, study_var_explained = cond_r2 - marg_r2, df_used = df - lag(df))
r2_table$step <- c("just study random effect",
                "+ next host in cycle",
                "+ intermediate or definitive host",
                "+ next host x int vs def",
                "+ worm size",
                "+ worm size x stage",
                "+ host mass",
                "+ host mass x stage"
                )
r2_table$LRT_pval <- round(lrt$`Pr(>Chisq)`, 5)
r2_table <- dplyr::select(r2_table, step, df_used, LRT_pval,
                          # VF, VR, VD, VE, 
                          marg_r2, cond_r2, study_var_explained)

```

Here's the R^2^ table. Studies vary a lot in the dose used - by itself the study random effect explains over 90% of the variation in dose. This suggests that a random effects model might be overkill; given that there is little variation within studies, we could probably just model the unique combinations of dose and study. On the other hand, the marginal R^2^ goes up to over 50% in the most complex model, indicating that differences among studies can be explained by differences in life stage, worm size, and host mass.

```{r}
r2_table
```

Let's plot some of these effects. To get CIs, we'll fit the model again with `MCMCglmm`.

```{r}
# for MCMCglmm, need to add "missing" data, as new data for predictions
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm))

dxx <- group_by(datx, nh_fac, to_int_def)%>%
  summarize(min_hm = min(log_hm, na.rm = T),
            max_hm = max(log_hm, na.rm = T),
            min_ws = min(log_ws, na.rm = T),
            max_ws = max(log_ws, na.rm = T),
            mean_hm = mean(unique(log_hm), na.rm = T),
            mean_ws = mean(unique(log_ws), na.rm = T))

dxy1 <- bind_rows(
  data.frame(nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[1], dxx$max_hm[1], length.out = 50),
             log_ws = dxx$mean_ws[1]),
  data.frame(nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[2], dxx$max_hm[2], length.out = 50),
             log_ws = dxx$mean_ws[2]),
  data.frame(nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[3], dxx$max_hm[3], length.out = 50),
             log_ws = dxx$mean_ws[3]),
  data.frame(nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[4], dxx$max_hm[4], length.out = 50),
             log_ws = dxx$mean_ws[4]),
  data.frame(nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[5], dxx$max_hm[5], length.out = 50),
             log_ws = dxx$mean_ws[5]),
  data.frame(nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[6], dxx$max_hm[6], length.out = 50),
             log_ws = dxx$mean_ws[6])
)
dxy1 <- dxy1%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = fct_relevel(st_id, c("1 Intermediate", "1 Definitive",
                                      "2 Intermediate", "2 Definitive",
                                      "3 Intermediate", "3 Definitive")))
dxy1$pred <- 'yes, hm'
dx <- bind_rows(dx, dxy1)


dxy2 <- bind_rows(
  data.frame(nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_ws = seq(dxx$min_ws[1], dxx$max_ws[1], length.out = 50),
             log_hm = dxx$mean_hm[1]),
  data.frame(nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_ws = seq(dxx$min_ws[2], dxx$max_ws[2], length.out = 50),
             log_hm = dxx$mean_hm[2]),
  data.frame(nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_ws = seq(dxx$min_ws[3], dxx$max_ws[3], length.out = 50),
             log_hm = dxx$mean_hm[3]),
  data.frame(nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_ws = seq(dxx$min_ws[4], dxx$max_ws[4], length.out = 50),
             log_hm = dxx$mean_hm[4]),
  data.frame(nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_ws = seq(dxx$min_ws[5], dxx$max_ws[5], length.out = 50),
             log_hm = dxx$mean_hm[5]),
  data.frame(nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_ws = seq(dxx$min_ws[6], dxx$max_ws[6], length.out = 50),
             log_hm = dxx$mean_hm[6])
)
dxy2 <- dxy2%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = fct_relevel(st_id, c("1 Intermediate", "1 Definitive",
                                      "2 Intermediate", "2 Definitive",
                                      "3 Intermediate", "3 Definitive")))
dxy2$pred <- 'yes, ws'
dx <- bind_rows(dx, dxy2)

dxy3 <- dxx%>%
  rename(log_ws = mean_ws, log_hm = mean_hm)%>%
  mutate(study_rs = unique(dat$study_rs)[1])%>%
  select(-min_hm, -max_hm, -min_ws, -max_ws)%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = fct_relevel(st_id, c("1 Intermediate", "1 Definitive",
                                      "2 Intermediate", "2 Definitive",
                                      "3 Intermediate", "3 Definitive")))
dxy3$pred <- 'yes, means'
dx <- bind_rows(dx, dxy3)

rm(dxx)
```
```{r}
rs <- (lme4::VarCorr(lmd7)["study_rs"][[1]])
attributes(rs) <- NULL
startc <- list(R = attr(lme4::VarCorr(lmd7), "sc")^2, 
               G = list(G1 = rs ),
               QUASI = FALSE)

# refit model
mod_dose <- MCMCglmm(log_dose ~ nh_fac * to_int_def * log_ws + nh_fac * to_int_def * log_hm, 
                 random = ~ study_rs,
                 prior = prior2,
                 start = startc,
                 nitt = 51000, thin = 50, burnin = 1000,
                 data = dx,
                 family = 'gaussian', pr=F, 
                 verbose = F)
```
```{r}
# predicted values and SE
p <- predict(mod_dose, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~study_rs
             )
p <- cbind(dx, p)
```

Here is the model summary. Notably, the distinction between intermediate and definitive hosts is not important.

```{r}
summary(mod_dose)
```

```{r}
# since studies have such clear affect, plot at level of studies
dose_per_study <- filter(datx, !is.na(log_ws), !is.na(log_hm))%>%
  group_by(Study, study_rs, Dose, nh_fac, to_int_def)%>%
  summarize(n = n(), # number of recovery rates at given dose in study
            n_hosts = sum(n_hosts), # total number of hosts exposed
            log_ws = mean(log_ws),
            log_hm = mean(log_hm),
            )%>%
  ungroup()
```

First, here is the change in dose used with life cycle stage. The size of the points correspond to the number of exposures at that dose for the study. Lower doses are used with later life stages. The difference between intermediate and definitive hosts is caused by differences in host mass.

```{r}
f5a <- ggplot(dose_per_study,
              aes(x = nh_fac, shape = to_int_def, y = Dose)) +
  geom_boxplot(outlier.colour = NA) + 
  geom_point(aes(size = n_hosts),
             position = position_jitterdodge(jitter.width = 0.5),
             alpha = 0.3) +
  geom_pointrange(data = filter(p, pred == "yes, means"),
                  aes(x = nh_fac, shape = to_int_def, y = exp(fit), ymin = exp(lwr), ymax = exp(upr)),
                  size = 1.5,
                  position = position_dodge(width = 0.75)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_size_continuous(trans = "log10") + 
  theme(panel.grid.major.x = element_blank(),
        legend.position = "bottom") +
  guides(size = F, shape = guide_legend(override.aes = list(alpha = 1, size = 3))) +
  labs(x = "Host in life cycle exposed", y = "Dose",
       shape = "")
f5a
# ggsave(f5a, filename = "../../figs/fig5.png", width = 4, height = 4)
# ggsave(f5a, filename = "../../figs/fig5.svg", width = 4, height = 4) # remove boxes under legend
```

Mean dose decreases with life cycle stage. The CIs seem a little overconfident, though. Let's pool all exposures from the same study at the same dose and refit the model.

```{r}
dose_per_studyx <- bind_rows(dose_per_study, dxy1, dxy2, dxy3)%>%
  mutate(log_dose = log(Dose))
```

```{r}
# refit model
mod_dose2 <- MCMCglmm(log_dose ~ nh_fac * to_int_def * log_ws + nh_fac * to_int_def * log_hm, 
                 random = ~ study_rs,
                 # prior = prior2,
                 # start = startc,
                 nitt = 51000, thin = 50, burnin = 1000,
                 data = dose_per_studyx,
                 family = 'gaussian', pr=F, 
                 verbose = F)
```

The study effect (red) obviously goes down after pooling, as there is less replication within studies.

```{r}
plot(mcmc.list(mod_dose$VCV[,"study_rs"], mod_dose2$VCV[,"study_rs"]), density = F)
```

The means and CIs from this model are not much different, suggesting pooling within studies does not have a big impact.

```{r}
# predicted values and SE
p2 <- predict(mod_dose2, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~study_rs
             )
p2 <- cbind(dose_per_studyx, p2)
```
```{r}
f5a <- ggplot(dose_per_study,
              aes(x = nh_fac, shape = to_int_def, y = Dose)) +
  geom_boxplot(outlier.colour = NA) + 
  geom_point(aes(size = n_hosts),
             position = position_jitterdodge(jitter.width = 0.5),
             alpha = 0.3) +
  geom_pointrange(data = filter(p2, pred == "yes, means"),
                  aes(x = nh_fac, shape = to_int_def, y = exp(fit), ymin = exp(lwr), ymax = exp(upr)),
                  size = 1.5,
                  position = position_dodge(width = 0.75)) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_size_continuous(trans = "log10") + 
  theme(panel.grid.major.x = element_blank(),
        legend.position = "bottom") +
  guides(size = F, shape = guide_legend(override.aes = list(alpha = 1, size = 3))) +
  labs(x = "Host in life cycle exposed", y = "Dose",
       shape = "")
f5a
```

What about the two covariates parasite size and host size? Does dose vary with them?

Dose decreases with worm size, mainly across life stages, but also within them.

```{r}
f6a <- ggplot(dose_per_study,
              aes(x = exp(log_ws), color = nh_fac, y = Dose, linetype = to_int_def)) +
  geom_point(aes(size = n_hosts),
             alpha = 0.3) +
  geom_line(data = filter(p, pred == "yes, ws"),
            aes(x = exp(log_ws), y = exp(fit)),
            size = 2) +
  geom_ribbon(data = filter(p, pred == "yes, ws"),
              aes(x = exp(log_ws), ymin = exp(lwr), ymax = exp(upr), fill = nh_fac), 
              alpha = 0.3, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  scale_linetype_manual(values = c("dashed","solid")) + 
  scale_size_continuous(trans = "log10") + 
  labs(y = "Dose", 
       x = bquote("Worm size " (~mm^3)),
       linetype = "Host type",
       fill = "Host\nexposed") +
  # facet_wrap(~to_int_def) +
  guides(color = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1))
         # shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))
         ) + 
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = "(a)", 
           x = min(exp(dose_per_study$log_ws)), 
           y = max(dose_per_study$Dose))
f6a
```

Dose increases with host mass within and across stages. The different doses used for intermediate and definitive hosts also looks like it can be explained by host mass.

```{r}
f6b <- ggplot(dose_per_study,
              aes(x = exp(log_hm), color = nh_fac, y = Dose, linetype = to_int_def)) +
  geom_point(aes(size = n_hosts),
             alpha = 0.3) +
  geom_line(data = filter(p, pred == "yes, hm"),
            aes(x = exp(log_hm), y = exp(fit)),
            size = 2) +
  geom_ribbon(data = filter(p, pred == "yes, hm"),
              aes(x = exp(log_hm), ymin = exp(lwr), ymax = exp(upr), fill = nh_fac), 
              alpha = 0.3, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  scale_linetype_manual(values = c("dashed","solid")) + 
  scale_size_continuous(trans = "log10") + 
  labs(y = "Dose", 
       x = "Host mass (g)",
       linetype = "Host type",
       fill = "Host\nexposed") +
  # facet_wrap(~to_int_def) +
  guides(color = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1))
         # shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))
         ) + 
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = "(b)", 
           x = min(exp(dose_per_study$log_hm)), 
           y = max(dose_per_study$Dose))
f6b
```

Since the model suggested that differences between intermediate and definitive hosts were not important, let's re-fit the dose model without this term.

```{r}
# for MCMCglmm, need to add "missing" data, as new data for predictions
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm))

dxx <- group_by(datx, nh_fac)%>%
  summarize(min_hm = min(log_hm, na.rm = T),
            max_hm = max(log_hm, na.rm = T),
            min_ws = min(log_ws, na.rm = T),
            max_ws = max(log_ws, na.rm = T),
            mean_hm = mean(unique(log_hm), na.rm = T),
            mean_ws = mean(unique(log_ws), na.rm = T))

dxy1 <- bind_rows(
  data.frame(nh_fac = "1", study_rs = unique(dat$study_rs)[1],
             log_hm = seq(dxx$min_hm[1], dxx$max_hm[1], length.out = 50),
             log_ws = dxx$mean_ws[1]),
  data.frame(nh_fac = "2", study_rs = unique(dat$study_rs)[1],
             log_hm = seq(dxx$min_hm[2], dxx$max_hm[2], length.out = 50),
             log_ws = dxx$mean_ws[2]),
  data.frame(nh_fac = "3", study_rs = unique(dat$study_rs)[1],
             log_hm = seq(dxx$min_hm[3], dxx$max_hm[3], length.out = 50),
             log_ws = dxx$mean_ws[3])
)

dxy1$pred <- 'yes, hm'
dx <- bind_rows(dx, dxy1)

dxy2 <- bind_rows(
  data.frame(nh_fac = "1", study_rs = unique(dat$study_rs)[1], 
             log_ws = seq(dxx$min_ws[1], dxx$max_ws[1], length.out = 50),
             log_hm = dxx$mean_hm[1]),
  data.frame(nh_fac = "2", study_rs = unique(dat$study_rs)[1], 
             log_ws = seq(dxx$min_ws[2], dxx$max_ws[2], length.out = 50),
             log_hm = dxx$mean_hm[2]),
  data.frame(nh_fac = "3", study_rs = unique(dat$study_rs)[1], 
             log_ws = seq(dxx$min_ws[3], dxx$max_ws[3], length.out = 50),
             log_hm = dxx$mean_hm[3])
)

dxy2$pred <- 'yes, ws'
dx <- bind_rows(dx, dxy2)

rm(dxx)
```
```{r}
# refit model
mod_dose_noid <- MCMCglmm(log_dose ~ nh_fac * log_ws + nh_fac * log_hm, 
                 random = ~ study_rs,
                 prior = prior2,
                 start = startc,
                 nitt = 51000, thin = 50, burnin = 1000,
                 data = dx,
                 family = 'gaussian', pr=F, 
                 verbose = F)
```
```{r}
# predicted values and SE
p <- predict(mod_dose_noid, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~study_rs
             )
p <- cbind(dx, p)
```

Including the int vs def distinction (red) only marginally lowers the model deviance.

```{r}
plot(mcmc.list(mod_dose_noid$Deviance, mod_dose$Deviance), density = F)
```

And the DIC is better without this term in the model.

```{r}
cat("delta DIC, without vs with int/def distinction:", round(mod_dose_noid$DIC - mod_dose$DIC, 2), "(higher is better)")
```

Here are the model predictions, after removing the intermediate vs definitive host distinction.

```{r}
f6a <- ggplot(dose_per_study,
              aes(x = exp(log_ws), color = nh_fac, y = Dose)) +
  geom_point(
    # aes(size = n_hosts),
    position = position_jitter(0.1),
    size = 0.75, alpha = 0.3) +
  geom_line(data = filter(p, pred == "yes, ws"),
            aes(x = exp(log_ws), y = exp(fit)),
            size = 2) +
  geom_ribbon(data = filter(p, pred == "yes, ws"),
              aes(x = exp(log_ws), ymin = exp(lwr), ymax = exp(upr), fill = nh_fac), 
              alpha = 0.3, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  # scale_size_continuous(trans = "log10") + 
  labs(y = "Dose", 
       x = bquote("Worm size " (~mm^3)),
       fill = "Host\nexposed",
       size = "Number of\nhosts exposed") +
  guides(color = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1))
         # shape = guide_legend(order = 2, override.aes = list(size = 3, alpha = 1))
         ) + 
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = "(a)", 
           x = min(exp(dose_per_study$log_ws)), 
           y = max(dose_per_study$Dose))
f6a
```


```{r}
f6b <- ggplot(dose_per_study,
              aes(x = exp(log_hm), color = nh_fac, y = Dose)) +
  geom_point(
    # aes(size = n_hosts),
    position = position_jitter(0.1),
    size = 0.75, alpha = 0.3) +
  geom_line(data = filter(p, pred == "yes, hm"),
            aes(x = exp(log_hm), y = exp(fit)),
            size = 2) +
  geom_ribbon(data = filter(p, pred == "yes, hm"),
              aes(x = exp(log_hm), ymin = exp(lwr), ymax = exp(upr), fill = nh_fac), 
              alpha = 0.3, color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  scale_fill_brewer(palette = "Dark2", direction = -1) + 
  scale_linetype_manual(values = c("dashed","solid")) + 
  # scale_size_continuous(trans = "log10") + 
  labs(y = "Dose", 
       x = "Host mass (g)",
       fill = "Host\nexposed",
       size = "Number of\nhosts exposed") +
  guides(
         color = F,
         fill = guide_legend(order = 1, override.aes = list(alpha = 1))
         ) + 
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = "(b)", 
           x = min(exp(dose_per_study$log_hm)), 
           y = max(dose_per_study$Dose))
f6b
```

Finally, let's refit the model, but with just the predicted recovery rates from the mixed models. The predicted recovery rates combine info on life stage, worm size, and host mass.


```{r}
# recreate the data used to fit final model
dx <- filter(datx, !is.na(log_ws), !is.na(log_hm), !is.na(log_dpi))

mdpi <- median(dx$log_dpi, na.rm = T)

dxx <- group_by(datx, nh_fac, to_int_def)%>%
  summarize(min_hm = min(log_hm, na.rm = T),
            max_hm = max(log_hm, na.rm = T),
            mean_ws = mean(unique(log_ws), na.rm = T))
dxy <- bind_rows(
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[1], dxx$max_hm[1], length.out = 50),
             log_ws = dxx$mean_ws[1]),
  data.frame(log_dpi = mdpi, nh_fac = "1", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[2], dxx$max_hm[2], length.out = 50),
             log_ws = dxx$mean_ws[2]),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[3], dxx$max_hm[3], length.out = 50),
             log_ws = dxx$mean_ws[3]),
  data.frame(log_dpi = mdpi, nh_fac = "2", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[4], dxx$max_hm[4], length.out = 50),
             log_ws = dxx$mean_ws[4]),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Intermediate",
             log_hm = seq(dxx$min_hm[5], dxx$max_hm[5], length.out = 50),
             log_ws = dxx$mean_ws[5]),
  data.frame(log_dpi = mdpi, nh_fac = "3", study_rs = unique(dat$study_rs)[1], to_int_def = "Definitive",
             log_hm = seq(dxx$min_hm[6], dxx$max_hm[6], length.out = 50),
             log_ws = dxx$mean_ws[6])
)
dxy <- dxy%>%
  mutate(to_int_def = fct_relevel(to_int_def, c("Intermediate", "Definitive")))%>%
  mutate(st_id = factor(paste(nh_fac, to_int_def)))%>%
  mutate(st_id = fct_relevel(st_id, c("1 Intermediate", "1 Definitive",
                                      "2 Intermediate", "2 Definitive",
                                      "3 Intermediate", "3 Definitive")))
dxy$pred <- 'yes'
dx <- bind_rows(dx, dxy)
rm(dxx, dxy, mdpi)
```
```{r}
# get predictions
p <- predict.MCMCglmm(modp4.2p, 
                      type = 'terms',
                      interval = 'confidence', 
                      level = 0.5,
                      marginal = ~ us(1+log_dpi):study_rs # ignore random effects
                      )
# p <- boot::inv.logit(p) # convert to proportions
dx <- cbind(dx, p)
dx <- mutate(dx, predicted_rr = boot::inv.logit(fit), 
             predicted_rr_upr = boot::inv.logit(upr), 
             predicted_rr_lwr = boot::inv.logit(lwr))
dx <- filter(dx, is.na(pred))%>%select(-pred, -fit, -upr, -lwr)

```
```{r}
# for model predicted dose
dxy <- data.frame(study_rs = unique(dat$study_rs)[1], predicted_rr = seq(0,1, by=0.02),
                  pred = "yes, rr")
dx <- bind_rows(dx, dxy)
rm(dxy)
```

```{r}
mod_dose_prr <- MCMCglmm(log_dose ~ predicted_rr, 
                 random = ~ study_rs,
                 prior = prior2,
                 start = startc,
                 nitt = 51000, thin = 50, burnin = 1000,
                 data = dx,
                 family = 'gaussian', pr=F, 
                 verbose = F)
```

```{r}
# predicted values and SE
p <- predict(mod_dose_prr, 
             type = 'terms',
             interval = 'confidence', 
             # ignore random effects
             marginal = ~study_rs
             )
p <- cbind(dx, p)
p <- filter(p, pred == "yes, rr")
```

```{r}
f6c <- ggplot(filter(dx, !is.na(nh_fac)),
       aes(x = predicted_rr, y = exp(log_dose))) +
  geom_point(aes(color = nh_fac),
             # position = position_jitter(0.1),
             size = 0.75, alpha = 0.3
             ) +
  # geom_smooth(method = lm, se = F, color = "black", linetype = "dotted") +
  geom_line(data = p,
            aes(x = predicted_rr, y = exp(fit)),
            size = 2) +
  geom_ribbon(data = p, 
              aes(x = predicted_rr, ymin = exp(lwr), ymax = exp(upr)),
              alpha = 0.3, fill = "darkgray", color = NA) +
  scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  scale_color_brewer(palette = "Dark2", direction = -1) + 
  labs(x = "Predicted recovery rate", y = "Dose", color = "Host\nexposed") +
  guides(
         color = guide_legend(order = 1, override.aes = list(alpha = 1))
         ) + 
  theme(panel.grid.minor = element_blank()) +
  annotate("text", label = "(c)", 
           x = 0, 
           y = max(dose_per_study$Dose))
f6c
```

```{r}
f6a2 <- f6a +
  theme(legend.position = "none")
f6b2 <- f6b +
  theme(legend.background = element_rect(color = "black"),
        legend.position = c(0.25,0.8),
        legend.text = element_text(size = 9),
        axis.title.y = element_blank(),
        axis.text.y = element_blank())
f6c2 <- f6c +
  theme(legend.position = "none",
        axis.title.y = element_blank(),
        axis.text.y = element_blank())
```

```{r}
f6 <- cowplot::plot_grid(f6a2, f6b2, f6c2,
                         align = "hv", nrow = 1)
ggsave(f6, filename = "../../figs/fig5.png", width = 12, height = 4)
ggsave(f6, filename = "../../figs/fig5.svg", width = 12, height = 4)
```

Thus, experimenters usually use higher doses in situations where lower infection rates are expected.

```{r}
save.image(file = "ER_analysis_aftermod.RData")
```

```{r}
# write nice data files for dryad
datx_out <- datx%>%
  mutate(dpi = exp(log_dpi))%>%
  select(parasite_species = Species, parasite_genus, parasite_family, parasite_order, parasite_class,
         parasite_phylum, host_species = Host_Species, host_genus, host_class,
         host_in_cycle_exposed = nh_fac, to_int_def, 
         dpi, dose = Dose, sample_size = n_hosts, 
         tot_given, tot_recovered = tot_inf, recovery_rate = Recovery_Rate,
         log_ws, log_hm, study = Study)
         
write.csv(datx_out, file = "../../data/recovery_rates_condition_level.csv", row.names = F)

dat_out <- dat%>%
  mutate(likely_undercount = if_else(Detect_Problem, "yes", "no"))%>%
  select(parasite_species = Species, parasite_genus, parasite_family, parasite_order, parasite_class,
         parasite_phylum, host_species = Host_Species, host_genus, 
         host_in_cycle_exposed = nh_fac, to_int_def, 
         exposure_type = Exposure_Type,
         likely_undercount, 
         dpi = Time_Dissection, dose = Dose, sample_size = Sample_Size, 
         tot_given, tot_recovered = tot_inf, recovery_rate = Recovery_Rate,
         worm_length = avg_length, worm_width = avg_width, 
         worm_volume = biovolume, imputed_worm_volume = imp_biovolume, log_ws,
         host_bm, log_hm, study = Study)

write.csv(dat_out, file = "../../data/recovery_rates_infection_level.csv", row.names = F)
```

